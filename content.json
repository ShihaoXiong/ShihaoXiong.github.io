{"pages":[{"title":"","text":"Hi there 👋, I am Shihao Xiong. · Resume · 👨‍🎓 Candiate of MSCS | 📍 New York City, US 💻 Tech Stack ✨ Get in Touch ✨","link":"/about/index.html"}],"posts":[{"title":"Ajax","text":"Ajax 教程 Ajax 的使用 创建 XMLHttpRequest 对象； 12345678//兼容处理var xhr = null;if (window.XMLHttpRequest) { xhr = new XMLHttpRequest();} else { //IE6及以下版本 xhr = new ActiveXObject('Microsoft.XMLHTTP');} 准备发送网络请求； 12345//get请求xhr.open('get', 'url?key=' + value, true);//post请求xhr.open('post', 'url', true); 开始发送网络请求； 12345678//get请求xhr.send(null);//post请求var param = 'key=' + value;//设置xhr端请求头信息，仅适用于post请求xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');xhr.send(param); 制定回调函数； 12345678910xhr.onreadystatechange = function () { if (xhr.readyState == 4) { if (xhr.status == 200) { //返回除XML之外的格式 var result = xhr.responseText; //返回XML var result = xhr.responseXML; } }}; readyState readyState=0：xhr 对象创建完成； readyState=1：已经发送了请求； readyState=2：浏览器已经收到了服务器响应的数据； readyState=3：正在解析数据； readyState=4：数据已经解析完成，可以使用； status 200：响应成功； 404：没有找到请求的资源； 500：服务器端错误； 同步与异步js 中异步原理：单线程+事件队列 数据格式数据格式：将数据通过一定的规范组织起来 xml 数据格式xml 数据格式是将数据以标签的方式进行组装 ，必须以 &lt;?xml version=&quot;1.0&quot; encoding=&quot;USF-8&quot; ?&gt; 开头。缺点：体积太大，传输慢，原数据太多，解析不方便； Json 数据格式优点：体积小，传输快，解析方便；Json 格式字符串转换为对象： JSON.parse() jQuery 中的 Ajax $.ajax({}) $.get(url(+param),function(){}) $.post(url,{key:value},function(){}) 跨域同源策略： 1. 协议相同 (http/https)； 2. 域名相同； 3. 端口号相同； 引入外部 js 文件&lt;script type=&quot;text/javascript&quot; src=&quot;http://...&quot;&gt;&lt;/script&gt; 动态创建 script 标签 (src)12345//DOM操作var script = document.createElement('script');script.src = 'http://...?key=' + value;var head = document.querySelector('head');head.appendChild(script); 动态制定回调函数123window['函数名'] = function () { //函数体}; jQuery Ajax 跨域1234567891011121314$.ajax({ url: ..., ..., //设置dataType的值为jsonp来跨域获取 dataType: &quot;jsonp&quot;, //设置jsonp的值来修改回调函数的key值(callback/cb)，默认callback //设置jsonpCallpack的值来修改回调函数的value(函数名) jsonp: &quot;cb&quot;, jsonpCallback: &quot;fun&quot; //成功后 success: function(data) { //data为返回的数据 }}) 模版引擎 (artTemplate)使用步骤 引入 js 文件； 定义模板； 1234&lt;script type=&quot;text/html&quot; id=&quot;resultTemplate&quot;&gt; //循环生成 {{each arr as value i}} //模板html代码, 数据绑定使用`{{}}` {{/each}} //条件判断 {{if isShow}} //模板html代码 {{/if}}&lt;/script&gt; 将数据和模板结合起来生成 html 片段； 1234567//template方法的含义就是将数据和模板结合起来，生成html片段//第一个参数为模板id，第二个参数为传入的数据var data = { arr: [...], isShow: true}var html = template(&quot;resultTemplate&quot;,data); 将 html 片段渲染到界面中； 基本语法 得到数据中的值 {{value}} 循环操作 {{each result as value i}} {{/each}} 转义 {{#value}} 条件判断 {{if ...}} {{/if}}::有时可能需要对原始数据进行加工操作::","link":"/2021/07/09/Ajax/"},{"title":"ES6","text":"ECMAScript 和 JavaScript ECMA 是标准，JS 是实现 ECMAScript 简称ECMA或ES 兼容性ES6 (ES 2015) — IE10+, Chrome, FireFox, Mobile, NodeJS变量 var 可以重复声明； 无法限制修改； 没有块级作用域； let 不能重复声明； 变量 — 可以修改； 块级作用域； const 不能重复声明； 常量 — 不能修改； 块级作用域； 函数箭头函数12345678function func() { //函数体}//箭头函数形式() =&gt; { //函数体}; 如果只有一个参数，()可以省略； 如果只有一个 return，{}可以省略； ::箭头函数 中的 this 引用的是最近作用域的对象:: 参数 参数扩展/数组展开 参数扩展；function func(a,b,...参数名) {} * Rest Parameter 必须是最后一个 数组展开；...arr * 展开后的结果和直接列出数组效果一样 123456//示例let arr1 = [1, 2, 3];let arr2 = [4, 5, 6];let arr = [...arr1, ...arr2];//以上结果为arr = [1,2,3,4,5,6] 默认参数 1234567//默认b=3, c=5function func(a, b = 3, c = 5) { //函数体}//传入参数后覆盖默认参数func(2, 5, 7); 解构赋值 左右两边结构必须一样； 右边必须是合理的数据类型； 声明和赋值必须在一句话里完成； 12345//arraylet [a, b, c] = [1, 2, 3];//jsonlet { a, b, c } = { a: 1, b: 2, c: 3 }; 数组新方法 .map() 映射 .reduce() 汇总 1234567891011121314151617//.reduce(callBackFun(previousValue,currentValue,index),initValue)let arr = [...];//求arr中总和let result = arr.reduce(function(tmp, item, index) { return tmp + item;});//求arr平均数let result = arr.reduce(function(tmp, item, index) { if(index!=arr.length-1) { return tmp + item; } else { return (tmp + item)/arr.length; }}); .filter() 过滤器 1234567891011//filter的回调函数必须返回布尔值//当返回为true时，会自动将这次回调 的item加到新的数组中//当返回为 false时，函数内部会过滤掉这个itemlet arr = [12, 5, 8, 99, 27, 36, 75, 11];let result = arr.filter(item =&gt; { return item % 3 == 0;});//12,99,27,36,75alter(result); .forEach() 循环 (迭代) 字符串新方法 .startsWith() .endsWith() 123let str = “abcdefg”;//truestr.startsWith(‘a’); 字符串模板 可用于字符串拼接 使用反单引号 可以折行 123let a = “b”;//str = “abcdefg”;let str = `a${a}cdeft`; 面向对象老版本面向对象12345678910111213141516171819202122232425262728293031function User(name, pass) { this.name = name; this.pass = pass;}User.prototype.showName = function() { alert(this.name);};User.prototype.showPasss = function() { alert(this.pass);};var u1 = new User(‘admin’,’123456’);u1.showName();u1.showPass();//继承function VipUser(name,pass,level) { User.call(this,name,pass); this.level = level;}VipuUser.prototype = new User();VipuUser.prototype.constructor = VipUser;VipuUser.prototype.showLevel = function() { alert(this.level);}var v1 = new VipUser(‘admin’,’123456’,3);v1.showName();v1.showPass();v1.showLevel(); ES6 面向对象定义_ class 关键字，构造器和类分开了_ class 里直接加方法 123456789101112131415161718192021222324252627282930313233class User { constructor(name,pass) { this.name = name; this.pass = pass; } showName() { alert(this.name); } showPasss() { alert(this.pass); }}var u1 = new User(‘admin’,’123456’);u1.showName();u1.showPass();//继承class VipUser extends User { constructor(name,pass,level) { super(name,pass); this.level = level; } showLevel() { alert(this.level); }}var v1 = new VipUser(‘admin’,’123456’,3);v1.showName();v1.showPass();v1.showLevel(); 对象字面量增强写法 属性的增强写法key 和 value 一样时，保留其一 1234let a = 12, b = 5;let json = { a, b, c: 55 }; 方法 (function)的增强写法 1234567891011121314let json = { a: 12, show: function() { //函数体 };}//以上可简写为let json = { a: 12, show() { //函数体 };} JSON需要转为 JSON 格式的字符串标准写法 key 只能用双引号 {“a”:12, ”b”:5} 所有字符串 value 必须用引号包起来 {“a”:”abc”, ”b”:5} JSON 对象 JSON.stringify() JSON 转为字符串 JSON.parse() 字符串转为 JSON Promise—异步编程的解决方案 异步：操作之间互不干涉，同时进行多个操作；代码更复杂； 同步：同时只完成一个任务；代码简单； Promise 的基本使用123456789101112131415new Promise((resolve, reject) =&gt; { //仿异步代码 setTimeout(() =&gt; { //resolve — 成功时调用 resolve(‘success’); //reject — 失败时调用 reject(‘failed’); }, 1000);}).then(res =&gt; { //res通过resolve传入 console.log(data);}).catch(err =&gt; { //err通过reject传入 console.log(err);}) Promise 的三种状态在异步操作之后会有三种状态： pending：等待状态，比如正在进行网络请求，或者定时器没有到时间 fulfill：满足状态，当主动回调了 resolve 时，就处于 fulfill 状态，并且会回调.then() reject：拒绝状态，当主动回调了 reject 时，就处于 fulfill 状态，并且会回调.catch() 另外处理形式在 then()里传入两个函数，第一个函数在 fulfill 状态调用，第二个函数在 reject 状态调用 123456789101112new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { //resolve — 成功时调用 resolve(‘success’); //reject — 失败时调用 reject(‘failed’); }, 1000);}).then(res =&gt; { console.log(data);}, err =&gt; { console.log(err);}) Promise 的链式调用有以下 Promise 嵌套，在后面两个 Promise 对象中没有进行异步操作 12345678910111213141516171819202122new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(data1); }, 1000);}) .then(res =&gt; { //处理data1 -&gt; data2 //... return new Promise(resolve =&gt; { resolve(data2); }); }) .then(res =&gt; { //处理data2 -&gt; data3 //... return new Promise(resolve =&gt; { resolve(data3); }); }) .then(res =&gt; { console.log(res); }); 以上代码可使用 Promise.resolve()进行简写： 123456789101112131415161718new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(data1); }, 1000);}) .then(res =&gt; { //处理data1 -&gt; data2 //... return Promise.resolve(data2); }) .then(res =&gt; { //处理data2 -&gt; data3 //... return Promise.resolve(data3); }) .then(res =&gt; { console.log(res); }); 对 Promise.resolve()简写： 123456789101112131415161718new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { resolve(data1); }, 1000);}) .then(res =&gt; { //处理data1 -&gt; data2 //... return data2; }) .then(res =&gt; { //处理data2 -&gt; data3 //... return data3; }) .then(res =&gt; { console.log(res); }); 多请求管理12345678910111213141516171819let p1 = new Promise((resolve, reject) =&gt; { //异步代码 resolve(‘res1’); reject(‘failed’);})let p2 = new Promise((resolve, reject) =&gt; { //异步代码 resolve(‘res2’); reject(‘failed’);})Promise.all([p1, p2]).then(data =&gt; { //两个请求都成功 //data为数组：[‘res1’, ‘res2’] console.log(data);}).catch(err =&gt; { //至少有一个请求失败 console.log(“failed”);}) Promise + jQuery123456//谁先完成，谁先返回//高版本jQuery自带PromisePromise.race([ $.ajax({...}), $.ajax({...})]); Generator—生成器函数 generator 函数可中断 以星号*定义 12345678910function *show() { alert(“a”); yield; //中断 alert(“b”);}//不能show()，必须定义对象let genObj = show();genObj.next(); //显示agenObj.next(); //显示b","link":"/2021/07/09/ES6/"},{"title":"Less","text":"Less 是一种动态样式语言，属于 css 预处理器的范畴，它扩展了 css 语言，增加了变量、mixin、函数等特性，使 css 更易维护和扩展。Less 可以在客户端上运行，也可以借助 node.js 在服务端运行。 Less 中的注释 以 // 开头的注释，不会被编译到 css 文件中 以 /**/ 包裹到注释会被编译到 css 文件中 变量使用@来声明一个变量 作为普通属性来使用直接使用 @param 1234@color: #ff0000;* { background: @color;} 作为选择器和属性名@{param} 123456789101112/* 选择器 */@selector: #container;@{selector} { position: relative; ...;}/* 属性名 */@m: margin;* { @{m}: 0;} 作为 url@{url} 变量的延迟加载在所有变量加载完成后才会执行使用变量的语句 Less 中的嵌套规则如下结构： 123&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 基本嵌套规则123456.outer { .inner { position: relative; ...; }} &amp;的使用12345678.outer { .inner { position: relative; ... &amp;:hover { ...; } }} Less 混合混合就是将一系列属性从一个规则集引入到另一个规则集的方式 普通混合/不带输出的混合123456789101112131415// 定义混合.mixin { position: absolute; ...;}// 使用.outer { .inner { .mixin; } .inner2 { .mixin; }} 带参数(且有默认值)的混合12345678910111213141516171819// 定义混合.mixin(@width: 200px, @height: 200px, @color: #00ff00) { position: absolute; width: @width; height: @height; background: @color; ...;}// 使用.outer { .inner { .mixin(100px, 100px, #ff0000); } .inner2 { /* 使用默认值 */ .mixin; }} 命名参数12345678910111213141516171819// 定义混合.mixin(@width: 200px, @height: 200px, @color: #00ff00) { position: absolute; width: @width; height: @height; background: @color; ...;}// 使用.outer { .inner { .mixin(100px, 100px, #ff0000); } .inner2 { /* 命名参数 */ .mixin(@color: #0000ff); }} 匹配模式1234567891011121314151617181920212223242526272829// 定义混合/* 定义同名混合，并且第一个参数为@_时，在使用混合时会自动调用第一个参数为@_的同名混合 */.mixin(@_) { width: 0; height: 0; border-width: 40px; border-style: solid;}/* top/right/bottom/left为匹配标识符，需要放在第一个参数，可自定义 */.mixin(top) { border-color: red, transparent, transparent, transparent;}.mixin(right) { border-color: transparent, red, transparent, transparent;}.mixin(bottom) { border-color: transparent, transparent, red, transparent;}.mixin(left) { border-color: transparent, transparent, transparent, red;}// 使用.triangle { .mixin(top); // .mixin(right); // .mixin(bottom); // .mixin(left);} arguments 变量1234567.mixin(@w, @s, @c) { border: @arguments;}.container { .border(1px, solid, #000000);} Less 运算1234.container { // 计算的一方带单位即可 width: 100 + 100px;} Less 继承::继承不能带参数::性能比混合高，灵活度比混合低如下示例： 1234&lt;div class=&quot;outer&quot;&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt; &lt;div class=&quot;inner&quot;&gt;&lt;/div&gt;&lt;/div&gt; 如果使用以下混入 123456789101112.mixin { // 内容1}.inner { &amp;:nth-child(1) { .mixin; } &amp;:nth-child(2) { .mixin; }} 编译结果为 123456789101112.inner:nth-child(1) { // 内容1}.inner:nth-child(2) { // 内容1}/* 以上结果会影响渲染性能，通过继承使得编译结果为以下格式 */.inner:nth-child(1),.inner:nth-child(2) { // 内容1} 使用继承 12345678910// 定义继承.extend { position: absolute; ...;}// 使用.inner:entend(.extend) { ...;} 编译结果为 123456.inner,.inner:nth-child(1),.inner:nth-child(2) { // 内容1}/* .inner被重复编译 */ 修改继承写法 1234567// 使用.inner { &amp;:extend(.extend); /* 使用all修饰符可继承extend所有属性，包括hover等伪类 */ &amp;:extend(.extend all);} Less 避免编译使用 ~&quot;&quot; 包含不需要 less 编译的内容 123.container { width: ~'calc(100px + 100)';}","link":"/2021/07/09/Less/"},{"title":"React","text":"特点 采用 组件化模式、声明式编码，提高开发效率 在 React Native 中可以使用 React 语法进行 移动端开发 使用虚拟 DOM+ Diffing 算法，尽量减少与真实 DOM 的交互 js 相关库 react.development.js react-dom.development.js babel.min.js 骨架12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; /&gt; &lt;title&gt;React&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 准备一个容器 --&gt; &lt;div id=&quot;test&quot;&gt;&lt;/div&gt; &lt;/body&gt; &lt;!-- 引入React核心库 --&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入React-dom，用于支持react操作dom --&gt; &lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt; &lt;!-- 引入babel，用于将jsx转换为js --&gt; &lt;script src=&quot;./babel.min.js&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/babel&quot;&gt; // 创建虚拟DOM const VDOM = &lt;div&gt;React&lt;/div&gt;; // 渲染虚拟DOM到页面 ReactDOM.render(VDOM, document.getElementById('test')); &lt;/script&gt;&lt;/html&gt; jsx 语法规则 定义虚拟 DOM 时，不要写引号 标签中混入 JS 表达式要用 {} 样式的类名指定不要用 class ，要使用 className 内联样式要用 style={{key: value}} 的形式去写 只有一个根标签 标签必须闭合 标签首字母 若小写字母开头，则将标签转为 html 中同名元素；若 html 中无该标签对应的同名元素，则报错 若大写字母开头， react 就去渲染对应的组件，若组件未定义，则报错 12345678// 创建虚拟DOMconst VDOM = ( &lt;div className='react-container'&gt; &lt;span style={{ color: 'blue' }}&gt;React&lt;/span&gt; &lt;/div&gt;);// 渲染虚拟DOM到页面ReactDOM.render(VDOM, document.getElementById('test')); 示例 注意区分 js 表达式和和 js 语句 表达式：一个表达式会产生一个值，可以放在任何一个需要的地方 a a + b demo(1) 有返回值 arr.map() function test () {} 语句（代码） 123456789101112131415const data = ['Angular', 'React', 'Vue'];// 创建虚拟DOMconst VDOM = ( &lt;div className='react-container'&gt; &lt;h1&gt;列表渲染&lt;/h1&gt; &lt;ul&gt; {data.map(item =&gt; { return &lt;li key={item}&gt;{item}&lt;/li&gt;; })} &lt;/ul&gt; &lt;/div&gt;);// 渲染虚拟DOM到页面ReactDOM.render(VDOM, document.getElementById('test')); 模块与组件、模块化与组件化 模块：向外提供特定功能的 js 程序，一般就是一个 js 文件 组件：用来实现局部功能效果的代码和资源的集合（html/css/js/image…） 模块化：当应用的 js 都以模块来编写，该应用就是一个模块化应用 组件化：当应用是以多组件的方式实现，该应用就是一个组件化应用 组件函数式组件12345678// 创建函数式组件function Component() { console.log(this); // undifined babel编译后开启了严格模式 return &lt;h2&gt;函数定义的组件，适用于简单组件的定义&lt;/h2&gt;;}// 渲染组件到页面ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); 类式组件 必须继承 React.Component 必须包含 render() 函数 render() 必须有返回值 1234567891011// 创建类式组件// 必须继承React.Componentclass Component extends React.Component { render() { console.log(this); // Component的（组件）实例对象 return &lt;h1&gt;类定义的组件，适用于复杂组件的定义&lt;/h1&gt;; }}// 渲染组件到页面ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); 组件实例三大核心属性State123456789101112131415class Component extends React.Component { // 构造器中是否接收props，是否传递给super，取决于是否希望在构造器中通过this访问props constructor(props) { // 必须调用super() super(props); // state必须是一个对象 this.state = { status: true }; } render() { return &lt;h1&gt;State: {this.state.status ? 'state1' : 'state2'}&lt;/h1&gt;; }}ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); setState状态不能直接更改，需要通过 setState 进行更新，更新是合并操作不是替换 1234567891011121314151617181920212223class Component extends React.Component { constructor(props) { // 必须调用super() super(props); // state必须是一个对象 this.state = { status: true, status2: true }; // 解决switchStatus中this指向问题 this.switchStatus = this.switchStatus.bind(this); } render() { // switchStatus不能添加小括号 return &lt;h1 onClick={this.switchStatus}&gt;State: {this.state.status ? 'state1' : 'state2'}&lt;/h1&gt;; } switchStatus() { let status = this.state.status; // 状态里的值不能直接更改 this.setState({ status: !status }); }}ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); 构造器执行了 1 次，render()函数执行了 1 + n 次 state 的简写方式123456789101112131415class Component extends React.Component { state = { status: true, status2: true }; render() { return &lt;h1 onClick={this.switchStatus}&gt;State: {this.state.status ? 'state1' : 'state2'}&lt;/h1&gt;; } // 箭头函数没有this指向，若在箭头函数中使用了this，箭头函数会找外层的this作为内部this的指向 switchStatus = () =&gt; { let status = this.state.status; this.setState({ status: !status }); };}ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); State 总结 组件中 render 方法中的 this 为组件实例对象 组件自定义的方法中 this 为 undefined，如何解决？ 强制绑定 this：通过函数对象的 bind() 箭头函数 状态数据，不能直接修改或更新，需要通过 setState Props Props 是只读的，不允许直接修改 通过标签属性从组件外向组建内传递变化的数据 组件内部不要修改 props 数据 基本使用123456789101112class Component extends React.Component { render() { console.log(this); return ( &lt;div&gt; &lt;h2&gt;参数：{this.props.param}&lt;/h2&gt; &lt;/div&gt; ); }}ReactDOM.render(&lt;Component param='param' /&gt;, document.getElementById('test')); 批量传递 props1234567891011121314class Component extends React.Component { render() { const { param1, param2 } = this.props; return ( &lt;div&gt; &lt;h2&gt;参数1：{param1}&lt;/h2&gt; &lt;h2&gt;参数2：{param2}&lt;/h2&gt; &lt;/div&gt; ); }}const params = { param1: 'param1', param2: 'param2' };ReactDOM.render(&lt;Component {...params} /&gt;, document.getElementById('test')); 对 props 进行限制在 16 版本以前可通过 React.PropTypes. ... 进行类型限制16 版本以后需要引入 PropTypes 1234567891011121314151617181920212223242526272829303132class Component extends React.Component { render() { const { param1, param2 } = this.props; return ( &lt;div&gt; &lt;h2&gt;类型限制：{param1}&lt;/h2&gt; &lt;h2&gt;值限制：{param2}&lt;/h2&gt; &lt;/div&gt; ); }}// 16版本以前写法// Component.propsTypes = {// param1: React.PropsTypes.string// };// 16版本以后写法Component.propTypes = { // 限制类型 param1: PropTypes.string, // 限制类型为函数 paramFunc: PropTypes.func, // 必传 param2: PropTypes.number.isRequired};// 默认值Component.defaultProps = { param1: '参数1'};ReactDOM.render(&lt;Component param1='param1' param2={2} /&gt;, document.getElementById('test')); Props 的简写通过 static 将属性直接加在组件类上 123456789101112131415161718class Component extends React.Component { static propTypes = { param1: PropTypes.string, paramFunc: PropTypes.func, param2: PropTypes.number.isRequired }; static defaultProps = { param1: '参数1' }; render() { const { param1, param2 } = this.props; return ( &lt;div&gt; &lt;h2&gt;类型限制：{param1}&lt;/h2&gt; &lt;h2&gt;值限制：{param2}&lt;/h2&gt; &lt;/div&gt; ); }} 函数式组件使用 Props12345678910111213function Component(props) { return ( &lt;div&gt; &lt;h2&gt;{props.params}&lt;/h2&gt; &lt;/div&gt; );}Component.propTypes = { params: PropTypes.string.isRequired };Component.defaultProps = { params: 'defaultParams' };// 渲染组件到页面ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); Refs字符串形式的 ref1234567891011121314class Demo extends React.Component { showValue = () =&gt; { const { input } = this.refs; console.log(input.value); }; render() { return ( &lt;div&gt; &lt;input ref='input' onBlur={this.showValue} /&gt; &lt;/div&gt; ); }} 回调形式的 ref 內联函数 1234567891011121314class Demo extends React.Component { showValue = () =&gt; { const { input } = this; console.log(input.value); }; render() { return ( &lt;div&gt; &lt;input ref={node =&gt; (this.input = node)} onBlur={this.showValue} /&gt; &lt;/div&gt; ); }} 回调执行次数：如果 ref 回调函数是以内联函数的方式定义的，在更新过程中它会被执行 两次 ，第一次传入参数 null，然后第二次会传入参数 DOM 元素。这是因为在每次渲染时会创建一个新的函数实例，所以 React 清空旧的 ref 并且设置新的。通过将 ref 的回调函数定义成 class 的绑定函数的方式可以避免上述问题。 class 的绑定函数 123456789101112131415161718class Demo extends React.Component { showValue = () =&gt; { const { input } = this; console.log(input.value); }; saveInput = node =&gt; { this.input = node; }; render() { return ( &lt;div&gt; &lt;input ref={this.saveInput} onBlur={this.showValue} /&gt; &lt;/div&gt; ); }} createRefReact.createRef 调用后可以返回一个容器，该容器可以储存被 ref 所标识的节点 current 是内置字段，不可更改 一个 createRef 只能装载一个 ref 12345678910111213141516class Demo extends React.Component { myRef = React.createRef(); showValue = () =&gt; { // current 是内置字段，不可更改 const { current } = this.myRef; console.log(current.value); }; render() { return ( &lt;div&gt; &lt;input ref={this.myRef} onBlur={this.showValue} /&gt; &lt;/div&gt; ); }} 事件绑定12345678910111213141516171819202122232425class Component extends React.Component { constructor(props) { // 必须调用super() super(props); // state必须是一个对象 this.state = { status: true }; // 解决switchStatus中this指向问题 this.switchStatus = this.switchStatus.bind(this); } render() { // switchStatus不能添加小括号 return &lt;h1 onClick={this.switchStatus}&gt;State: {this.state.status ? 'state1' : 'state2'}&lt;/h1&gt;; } switchStatus() { // switchStatus作为onClick回调，不是通过实例调用，而是直接调用， // 类中的方法默认开启了局部的严格模式，所以this为undefined // 需要使用 this.switchStatus = this.switchStatus.bind(this);改变this指向 console.log(this); // undefined this.state.status = !this.state.status; }}ReactDOM.render(&lt;Component /&gt;, document.getElementById('test')); 通过箭头函数实现事件绑定事件处理 通过 onXxx 属性指定事件处理函数（注意大小写） React 使用的是自定义（合成）事件，而不是使用原生的 DOM 事件——为了更好的兼容 React 中的事件是通过事件委托方式处理的（委托给组件最外层的元素）——为了高效 通过 event.target 得到发生事件的 DOM 元素对象 包含表单的组件分类非受控组件12345678910111213141516171819class Demo extends React.Component { handleSubmit = event =&gt; { event.preventDefault(); // 阻止默认行为 const { username, password } = this; console.log(`username: ${username.value}, password: ${password.value}`); }; render() { return ( &lt;form action='…' onSubmit={this.handleSubmit}&gt; 用户名： &lt;input ref={c =&gt; (this.username = c)} type='text' name='username' /&gt; 密码： &lt;input ref={c =&gt; (this.password = c)} type='password' name='password' /&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ); }} 受控组件12345678910111213141516171819202122232425262728class Demo extends React.Component { state = { username: '', password: '' }; saveUsername = event =&gt; { this.setState({ username: event.target.value }); }; savePassword = event =&gt; { this.setState({ password: event.target.value }); }; handleSubmit = event =&gt; { event.preventDefault(); // 阻止默认行为 const { username, password } = this; console.log(`username: ${username}, password: ${password}`); }; render() { return ( &lt;form action='…' onSubmit={this.handleSubmit}&gt; 用户名： &lt;input onChange={this.saveUsername} name='username' /&gt; 密码： &lt;input onChange={this.savePassword} name='password' /&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ); }} 高阶函数 &amp; 函数柯里化函数柯里化123456789101112131415161718192021222324252627class Demo extends React.Component { state = { username: '', password: '' }; saveFormData = dataType =&gt; { return event =&gt; { this.setState({ [dataType]: event.target.value }); }; }; handleSubmit = event =&gt; { event.preventDefault(); // 阻止默认行为 const { username, password } = this; console.log(`username: ${username}, password: ${password}`); }; render() { return ( &lt;form action='…' onSubmit={this.handleSubmit}&gt; 用户名： &lt;input onChange={this.saveFormData('username')} name='username' /&gt; 密码： &lt;input onChange={this.saveFormData('password')} name='password' /&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ); }} 高阶函数：如果一个函数符合下面 2 个规范中任何一个，那么该函数就是高阶函数 1. 接收的参数是一个函数 2. 调用的返回值是一个参数 常见的高阶函数： Promise setTimeout array.map … 函数的柯里化：通过函数调用继续返回函数的方式，实现多次接收参数最后统一处理的函数编码形式。 不用柯里化的写法12345678910111213141516171819202122232425class Demo extends React.Component { state = { username: '', password: '' }; saveFormData = (dataType, value) =&gt; { this.setState({ [dataType]: value }); }; handleSubmit = event =&gt; { event.preventDefault(); // 阻止默认行为 const { username, password } = this; console.log(`username: ${username}, password: ${password}`); }; render() { return ( &lt;form action='…' onSubmit={this.handleSubmit}&gt; 用户名： &lt;input onChange={event =&gt; this.saveFormData('username', event.target.value)} name='username' /&gt; 密码： &lt;input onChange={event =&gt; this.saveFormData('password', event.target.value)} name='password' /&gt; &lt;button&gt;登录&lt;/button&gt; &lt;/form&gt; ); }}","link":"/2021/07/29/React/"},{"title":"Java","text":"Primitive Types &amp; Basic Operationsbyte: 计算机最小存储单元 1234567891011122's complement: 按位取反再加10000 = 00001 = 10010 = 2...0111 = 7 -&gt; overflow1111 = -11110 = -2...1001 = -71000 = -8 -&gt; underflow Conclusions (n bits): total number of represented integers: 2n number of positives: 2(n-1) - 1 , number of negatives: 2(n-1) range: [-8, 7] Primitive Type Sotres Range byte 8-bit integer -128 to 127 short 16-bit integer -32,768 to 32,767 int 32-bit integer -2,147,483,648 to 2,147,483,647 long 64-bit integer -263 to 263 - 1 float 32-bit floating-point 6 significant digits (10-46, 1038) double 64-bit floating-point 15 significant digits (10-324, 10308) char Unicode character boolean Boolean variable false and true 取整遵循向零取整 Operators &amp; Precedence Operators Precedence postfix expr++, expr– unary ++expr, –expr, +expr, -expr, ~, ! multiplicative *, /, % additive +, - shift &lt;&lt;, &gt;&gt;, &gt;&gt;&gt; relational &lt;, &gt;, &lt;=, &gt;=, instanceof equality ==, != bitwise AND &amp; bitwise exclusive OR ^ bitwise inclusive OR | logical AND &amp;&amp; logical OR || ternary ? : assignment =, +=, -=, _=, /=, %=, &amp;=, _=, |=, &lt;&lt;=, &gt;&gt;+, &gt;&gt;&gt;= widening (精度) byte -&gt; short -&gt; int -&gt; long -&gt; float -&gt; double 高精度 -&gt; 低精度需要进行显示转换 12double x = 1.9int y = (int)x Control Flow &amp; MethodsControl Flow if...else if...else In Java, the expression in “()” must bt a bollean expression for whilebreak &amp; continute break: jumps out of the entire loop comtiunte: skip the current iteration Methods / Functions123[modifier] [return type] [name of the method](arguments) { // ...} Signature Name of the method The list of the parameter types **Q: What uniquely identifies a function?**A: function name + the list of parameter types Method Overloading(重载)函数名相同，但是 parameter type list 不同的 functions different types different num of parameters different order Return TypeIt can be a primitive type: int, double, char, boolean a class: TreeNode, ListNode, … void: no return value Array, Class &amp; Objects1D/2D Array1D Array Array is a form of data collection. It can be a collection of anything. Array elements occupy consecutive memory space. 12345678int[] empty = new int[5];int[] numbers = new int[]{4, 20, 7, 5, 10};int num = numbers[2];numbers[4] = 15;// traverse an arrayfor(int i = 0; i &lt; numbers.legnth; i++) {...}for(int num: numbers) {...} 2D Array1int[][] matrix = new int[][]{{2, 1}, {3, 4}, {8, 9}} Main FunctionMain function is the entry point the Java program; all other functions are directly or indirectly invoked by the main function. 123public static void main(String[] args) { // ...} The Object-Oriented Paradigm in Java 存储：和 primitive types 的对比 构造函数 更多关键词：static, final, public/private, this null basics -&gt; NullPointerException (NPE) Basic concept class object reference: the business card of object, find the object by ref. Working with ObjectsThe new keyword: create an object 1Student firstStudent = new Student(&quot;Tom&quot;); There are actually three important operations that happened in this statement. Declaration: associate a variable name with an object type 1Student firstStudent Instantiation: the new keyword is a Java operator that creates the object 1firstStudent = new Student(); Initialization: the new operator is followed by a call to a constructor, which initializes the new object 1Student firstStudent = new Student(&quot;Tom&quot;); Object Memory LayoutMemery spaces in a Kava program: Stack and Heap Stack: In computer science, a call stack is a stack data structure that stores information about the active subroutines of a computer program (stack frame). This kind of stack is also known as an execution stack, program stack, control stack, run-time stack, or machine stack, and is often shortened to just “the stack”. (LIFO) Heap: Java objects reside in an area called te heap. The heap is created when the JVM starts up and may increase or decrease in size while the application runs. (FIFO) Call Stack no function call, no call stack Stack + Heap Stack + Heap are memory (RAM) segments RAM: Random Access Memory Difference space: stack ~MB, heap ~GB read/write speed: srack (1 CPU instruction) &gt;&gt;&gt; heap(“bookkeeping”) Stack frame 1 function invocation -&gt; 1stack frame “pushed” onto the call stack (a pile of books) if a function is never called, its stack frame is never created Variable Scope Scope: lifetime and accessibility/visibility of a variable. How large the scope depends on where a variable is declared. Simply, the scope is the innermost {} warpping up the decalration. Local (local to function) variables: the variables whose lifetime is strictly tied with a function. Default Values It’s not always necessary to assign a value when a field is declared. Fields that are declared but not initailized will be set to a reasonable defalut by the compiler. The following chart summarizes the default values for the above data types. Data Type Default Value (for fields) byte 0 short 0 int 0 long 0L float 0.0f double 0.0d char ‘\\u0000’ any object null Java Parameter PassingJava function call is always pass by value (copy) primitive type: copy of the value itself reference: copy of the reference Variables and their scopeLocal variables must be initialized before use.One local variable has the lifetime of their own scope. In general, each pair of curly brackets defines a scope. Each variable is associated with the scope it defined in. Instance Variable (filed) instance filed == instance variable == member variable non-static variables defined within a class, but not within any methods instance variables have the same life cycle as the instance instance variables’ visibility is defined by their access modifiers instance variables hasve default values f they’re not initaialized by a constructor Local Variable Insrance Variable Location Stack Heap Lifetime Method call Instance lifetime Visibility Scope Modifier Default value N / A 0, false, null Initialzation Must set before read In declaration or constructor Objects, References &amp; NullStaticMembers (filed, methods) belong to class, not object (instance). 12345678910class Demo { public static isTrue = false; public static viod change() { // cannot use `this` isTrue = true; }}Demo.change();System.out.println(Demo.isTrue); // true cannot use this to access isTrue in here this usually been used as a Object variable with static means variables belong to class not object Static methods can (directly) access only static variables / methods Non-static method can access both static and non-static variables / methods Finalconstans, once assigned, cannot be changed. final class: A class that cannot be derived final method: A method that cannot be overridden final variable: Avariable that once assigned, cannot be assigned again Array &amp; Objectarrays are objects the elements in the array still occupy consecutive memory space on the heap “length” is a filed of the array object array length can not be changed after the array object is created. (final) Occupies consecutive memory and the elements in the array can be referenced via the index in O(1) time Exceptions / Error ArrayIndexOutOfBoundExpecption NullPointerException List, Queue, Deque List add(E e) add(int index, E e) remove(int index) remove(E e) set(int index, E e) E get(int index) int size() Queue offer(E e) E peek() E poll() Deque offerFirst(E e) offerLast(E e) E peekFirst() E peekLast() E pollFirst() E pollLast() Summary if you want to use a QueueQueue&lt;X&gt; queue = new ArrayDeque&lt;&gt;(); if you want to use a StackDeque&lt;X&gt; stack = new ArrayDeque&lt;&gt;(); if you want to use a two-end QueueDeque&lt;X&gt; dq = new ArrayDeque&lt;&gt;(); if you want to use a size-adjustable arrayList&lt;X&gt; list = new ArrayList&lt;&gt;(); if you want to use a priority queuePriorityQueue&lt;X&gt; pq = new PriorityQueue&lt;&gt;(); Set &amp; MapSetA collection that can not contain duplicate elements. HashSet: Which stores its elements in a hashtable, is the best-performing implementation, however it makes no guarantees concerning the order of iteration. TreeSet: Which stores it elements in a red-black tree (balanced binary search tree), orders its elements based on their value LinkedHashSet: It is a HashSet and also it is a LinkedList, it maintains the order when each of the elements is inserted into the HashSet MapA collection that maps keys to values. A Map cannot contain duplicate keys; each key can map to one value. HashMap TreeMap LinkedHashMap HashMapCommon API V put(K key, V value) V get(Object key) V remove(Object key) boolean containsKey(Object key) -&gt; O(n) boolean containsValue(Object value) void clear() int size() boolean isEmpty() Time Complexity Operation Average Worst (&lt;= JDK 7) search: boolean containsKey(Object key) V get(Object key) O(1) O(n) insert / update: V put(K key, V value) O(1) O(n) delete: V remove(Object key) V get(Object key) O(1) O(n) A HashMap Implementation A table of buckets (an array of buckets), using the array index to denote each bucket For each &lt;key, value&gt;, it goes to one of the buckets, the bucket index is determined by a hash function applied on key and the size of array Collision Control Collision - two keys mapped to the same bucket Separate Chaining (Close Addressing) - the element of each of the buckets is actually a single linked list Open addressing - put the key-value pair into the “next” available bucket How to define next? linear / quadratic / exponential probing, hash again Challenge: handing removed keys in the map Not used by Java, but by some real life systems If different keys are determined to use the same bucket, they will be chained in the list ==, equals() &amp; hashCode() == determine if two primitive types have the same value determine of two references are pointed to the same object equals(), hashCode() defined in Object calss, Object is the root class from any Java class any Java class implicity extends Object class, so if in the subclass these two methods are not overridden, it inherits what it defines in Object class the defalut implementation of equals() is check if the two references are pointed to the same object == the defalut implementation of hashCode() returns a “unique hash value” for the object based on its memory address Inheritance, Polymorphism, Access Modifier, ExceptionsInheritanceA class that is derived from another class is called a sbuclass (also a derived class, extended class, or child class). The class from which the sbuclass is derived is called s superclass (also a base class or a parent class). 1234567891011121314151617181920212223242526272829class Person { public final String name; private int age; public String getName() { return name; } public int getAge() { return age; } public void setAge(int age) { this.age = age; } public Person(String name) { this.name = name; }}class Employee extends Person { public String company; public void setCompany(String company) { this.company = company; } public String getCompany() { return company; } public Employee(String name) { super(name); }} Polymorphism使用父类的 reference 来指向子类的实现，并且调用子类里面 override 了父类的 method 哪些函数能够调用取决于 reference（声明）的类型 –compile time 对于被 override 的函数，调用哪个版本，取决于实现的类型 – runtime OverrideOverride is when you redefine a method that has been defined in a parent class (using the same signature). Resolved at runtime. OverloadOverload is when you define two methods with the same name, in the same class, distinguished by their signatures (different). Resolved at compile time. abstract vs. interfaceA class must be declared abstract when it has one or more abstract methods. A method is declared abstract when it has a method heading, but no boay - which means that an abstract method has no implementation code inside like normal methods do. Difference: An abstract class has one or more abstract methods, can have some non-abstract methods, constructors and instance variables as well, can have non-public members. An interface has only abstract methods. All methods must be public. Any class that implements the interface is responsible for providing the method definition / implementation. Java does not allow multiple inheritance. In Java, a class can only derive from one class, whether it’s abstract or not. However, a class can implement multiple interfaces. Java does not allow multiple extends, but a class can implements multiple interfaces. When use abstract class vs. interface? An abstract class is good if you think you will plan on using inheritance since it provides a common base class implementation to derived classes. An abstract class is also good if you want to be able to declare non-public members. In an interface, all methods must be public. If you think you will need to add non-abstract methods in the future, then an abstract class is a better choice. Because if you add new method headings to an interface, then all of the classes that already implement that interface will hace to be changed to implement the new methods. Interface are a good choice when you think that the API will not change for a while. Interface are also good when you want to hace something similar to multiple inheritance, since you can implement multiple interfaces. Access Modifier public: everyone can access private: only myself can access (but only at class level, other objects of the same calss can access as well) protected: only my children and same package can access default: only the same package can access Modifier Class Package Subclass World public Y Y Y Y protected Y Y Y N no modifier Y Y N N private Y N N N Exceptions 123456789101112131415161718class ExceptionTest { public void getException() { try { exception(); } catch (Exception err) { System.out.println(err); } } public void throwException() throws Exception { exception(); } public void exception throws Exception { throw new Exception(); }} throw vs. throws throw: The throw keyword in Java is used to explicitly throw an exception from a methods or any block of code. throws: Throws is a keyword in Java which is used in the head of method to indicate that this method might throw one of the listed type exceptions. The caller to these methods has to handle the exception if it they are checked exceptions. How to test code? smoke test unit test functional test integration test regression test performance / load / stress test end-to-end test balckbox / whitebox test JUnit TestAnnotations @Test: The Test annotation tells JUnit that the public void method to which it is attached can be run as a test case. @Before: Several tests need similar objects created before they can run. Annotating a public void method with @Before causes that method to be run before each Test method. @After: If you allocate external resources in a Before method, you need to release them after the test runs. Annotating a public void method with @After causes that method to be run after the Test method. @BeforeClass: Annotating a public static void method with @BeforeClass causes it to be run once before any of the test methods in the class. @AfterClass: This will perform the method after all tests hace finished. This can be used to perform clean-up activites. Note @BeforeClass runs once, at the very beginning AfterClass runs once, at the very end @Before runs before each test @After runs after each test Methods with @BeforeClass and @AfterClass must be static Assertions void assertEquals(int expected, int actual)Checks that two primitives / objects are equalvoid assertEquals(double expected, double actual, double delta) void assertTrue(boolean condition)Checks that a condition is true void assertFalse(boolean condition)Checks that a condition is false void assertNotNull(Object object)Checks that an object isn’t null void assertNull(Object object)Checks that an object is null void assertSame(Object a, Object b)The assertSame() method tests if two object references point ti the same object void assertArrayEquals(expectedArray, resultArray)The assertArrayEquals() method will test whether two arrays are equal to each other What is a good test case? Should be accurate and tests what it is intended to test. No unnecessary steps should be included in it. It should be resuable. It should be traceable to requirements. It should be independent. It should be simple and clear, any tester should be able to understand it by reading once. Nested Class, Iterators, Generics &amp; EnumNested Class (嵌套类)DefinitionA nested class is any class whose declaration occurs within the body of another class or interface. A top level class is a class that is not a nested class. 12345678class Demo { class InnerClass { // ... } static class NestedStaticClass { // ... }} It is a way of logically classes that are only used in one place It increases encapsulation It can lead to more readable and maintainable code Prefer nested static class to inner class (use inner class only when you need to access non-static member) IteratorsIterate through a Collection object (List, etc.) next() returns the next element in the iteration hasNext() returns true if the iteration has more elements remove() removes from the underlying collection the last element returned by this iterator (optional operation) Generics (泛型)DefinitionTypes are parametersA type or method to operate on objects of various types while providing compile-time type safety Java Generic methods and Generic classes enable programmers to specify with a single method declaration, a set of related methods with a single class declaration, a set of related types Generic Method Object only Syntax public static &lt;E, ...&gt; void demoMethod(E[] input, ...) public static &lt;E extends Integer &amp; Comparable&lt;E&gt; &amp; Iterable&lt;E&gt;&gt; void demoMethod(E[] input) Generic Class1234567class Demo&lt;T&gt; { private T value; public Demo(T v) { value = v; } // ...} 通配符 (Wildcard) ? extends (Upper Bounded Wildcard) ? super (Lower Bounded Wildcard) Enum values() can be used to return all values present inside Enum Order is important in enums. By using ordinal(), each enum constant index can be found, just like array index. valueOf() returns the enum constant of the specified string value, if exists. Basic Java File Read / WriteStreamA stream can be defined as a sequence of data. inputStream: The InputStream is used to read data from a source outputStream: The OutputStream is used from writing data to a destination C++ vs. Java (vs. Python), Grabage collectionDifferent between Java &amp; C++ Platform compatible, write once, compile once, run everywhere on JVM C++: write once, compile everywhere JVM: Java Virtual Machine JRE vs. JDK JRE (Java Runtime Environement) is the JVM program, Java application need to run on JRE JDK contains the tools for development Java programs rnuning on JRE, for example, it provides the conpile “javac” Compiler – 编译器 Interpreter – 解释器 Compiles to Java byte code can be recongnized by JVM, independent to underline OS. JVM (虚拟机) – The Java Virtual Machine (JVM) is an abstract computing machine The JVM is a program that looks a machine to the programs written to execute in it. JRE (java 运行时环境) JDK (java 开发工具包) Interpreter to routines on systems with different machine codes. Compile / Interpret LanguagePlatform compatibility: language virtual machine &lt;- Java, Python, JavaScript …Better performance: compile to native language (machine language) &lt;- C, C++, GO …C++: The source code need to be compiled to directly the machine instruction on which machine the program is rnuning on. The compiled byte code is different on different machines (machine need to recongnize the compiled code).Java: The source code just need to be compiled once and it can run on any machine with JRE installed.Python: 1. Interpreter: Python 2. Compiler: pyc Strongly encouraged Object-Oriented Programming Paradigm, everything in Java is class / object. All types (reference types, primitive types) are always passed by value Java does not support unsigned numbers Pointers vs. References no pointer arithmeticsDifference between pointers in C++ and reference in Java: references in Java are strongly typed There is no pointer arithmetic on references No operator overloading Classes / Objects are always allocated on the Heap, there is no way to allocate objects on Stack. Grabage Collection Single inheritance, multiple inheritance only be done by implementing multiple interfaces. Grabage CollectionThe heap is where your object data is stored. This area is then managed by the grabage collertor selected at startup. Step 1: MarkingThe first step in the process is called marking. This is where the garbage collector identifies which pieces of memory are in use and which are not. Referenced objects are shown in blue. Unreferenced objects are shown in gold. All objects are scanned in the marking phase to make this determination. This can be a very time consuming process if all objects in a system must be scanned. Step 2: Normal DeletionNormal deletion removes unreferenced objects leaving referenced objects and pointers to free space. The memory allocator holds references to blocks of free space where new object can be allocated. Step 2a: Deletion with CompactingTo further improve performance, in addition to deleting unreferenced objects, you can also compact the remaining referenced objects. By moving referenced object together, this makes new memory allocation much easier and faster. (fragment) There are four kinds of GC roots in Java Local variable are kept alive by the stack of a thread. Active Java threads Static Variables JNI (Java Native Interface) References ConcurrencyConcurrency vs. Parallel Concurrency: multiple tasks run simultaneously Parallel: multiple tasks physically run simultaneously Multiprocess vs. Multi-threadProcess: An independent execution of instructions with independent memory space, stack, heap, and 0S respurce .Each process sees a complete memory space (pretend to be the only task of a system. )Different processes communicates through interprocess communication (explicit IPC). Thread: An independent execution of instruction with shared memory space.Each thread has its private: stack, program counter and register states.Thread in the same process has shared: heap, static memory segment, os resource. Semantically, the fundamental difference between a “process” and a “thread” is if they have independent memory space. lmplementation-wise, there are corner cases. Be careful about your wording here. Java Thread1234567Thread t = new Thread();// Schedule the created thread and make ready to got.start();// Make sure the thread finished after this line. (Waits for thsi thread to die.)t.join(); When the JVM will exit? -&gt; no alive non-daemon threads A thread’s life cycle:start() -&gt; mark it as “read to run” stat -&gt; put into the ready to run queue and wait for the scheduler to assign its time frame (quota) for running -&gt; end of quota or stat change by different event:sleep() -&gt; remove from the ready to run queue, and move to sleeping thread poolwait() -&gt; removed from the ready to run queue, and moce to the conditions’ queue for singal to put back to the ready queueyield() -&gt; did not change the ready to run stat, but preempt itself the current quota, put back to the ready-to-run queue again for the next quota Synchronization &amp; Race Synchronization: the coordination of events to operate a system in unison If two“conflicting operations” are in different threads and are not properly synchronized (concurrent), they will introduce data races. In general, two operations conflict with each other if they operate on the same memory location, and at least one of them is a write. Races are mostly treated as bugs in Java programs. So to form a data race there should be 3 factors. More than one operations work on the same memory location At least one operation is a write At least two of those operations are concurrent Mutual exclusion (mutex), critical section, and locksConditions to form a deadlock: Mutual Exclusion: At least one resource must be held in a non-shareable mode. Only one process can use the resource at any given instant of time. Hold and Wait or Resource Holding: A process is currently holding at least one resource and requesting additional resources which are being held by other processes.←Avoid nesting critical sections! No Preemptin: a resoure can be rleased ony vluntarly by the poces hlding it Circular Wait TrieA data structure. More precisely, a search tree. 123456class TrieNode { // Maps a character to its corresponding child Map&lt;Character, TrieNode&gt; children; boolean isWord; int value;} or 123456789// Assumption: a key contains lower-case letters onlyclass TrieNode { // An array of size 26, each index -&gt; character // 0 -&gt; 'a', 1 -&gt; 'b', ... // 'c' -&gt; 'c' - 'a' = 2 TrieNode[] children; boolean isWord; int value;}","link":"/2021/07/09/Java/"},{"title":"Data Structure &amp; Algorithm","text":"Data StructureData structure is a particular way of organzing data in a computer so that it can be used efficiently. Common data structure Array Stack Queue Linked List Tree Heap Graph Hash Table UnionFind Trie … Time Complexity &amp; Space ComplexityBig O notation: algorithm complexity (time complexity(TC), space complexity(SC)) 1 &lt; log2n == log10(n) &lt; sqrt(n) &lt; n &lt; nlog n &lt; n^2 &lt; n^3 &lt; 2^n &lt; 10^n &lt; n! &lt; n^n ArrayListArrayList is regarded as a resizable array. 123456789101112131415161718import java.util.*;public class ArrayListDemo { public static void main(String[] args) { // byte -&gt; Byte // short -&gt; Short // int -&gt; Integer = int + null // long -&gt; Long // double -&gt; Double // char -&gt; Character // boolean -&gt; Boolean List&lt;Integer&gt; newList = new ArrayList&lt;Integer&gt;(); // {} newList.add(1); // {1} newList.add(9); // {1, 9} System.out.println(newList.get(1)); // 9 System.out.println(newList.size()); // 2 }} Binary SearchPrinciples of Binary Search We must guarantee that the search space decreases over time (after each iteration) We must guarantee that the target (if exists) cannot be ruled out accidentally, when we change the value of Left or Right. (It is critical to define the rule about how to move the range for search) Array has to be sorted. 可用的循环条件 不可用的循环条件 case1: right = mid - 1 case2: left = mid + 1 1. left &lt;= right 退出循环时一定是 empty 2. left &lt; right 退出循环时一定是一个元素或者 empty -&gt; 需要 postprocessing 3. left + 1 &lt; right 退出循环时一定是两个元素或者一个元素，不可能是 empty case1: right = mid - 1 case2: left = mid left + 1 &lt; right 退出循环时一定是两个元素或者一个元素，不可能是 empty 1. left &lt;= right 因为 length = 1 或 2 时，会出死循环 2. left &lt; right 因为 length = 2 时，会出死循环 case1: right = mid case2: left = mid + 1 1. left + 1 &lt; right 退出循环时一定是两个元素或者一个元素，不可能是 empty 2. left &lt; right 退出循环时一定是一个元素，不可能是 empty left &lt;= right 因为 length = 1 时，会出死循环 case1: right = mid case2: left = mid left + 1 &lt; right 退出循环时一定是两个元素或者一个元素，不可能是 empty 1. left &lt;= right 因为 length = 1 或 2 时，会出死循环 left &lt; right 因为 length = 2 时，会出死循环 Recursion, Queue &amp; StackRecursion 与计算的结合 表象上：function calls itself 实质上：Boil down a big problem to smaller ones (size n depends on size n-1, or n-2 or … n/2) Implementation 上：a. Base case: smallest problem to solveb. Recursion rule Example.1 Fibonacci Sequence f(n)0 1 2 3 4 5 6 7 …0 1 1 2 3 5 8 13 … f(n) subproblem: f(n - 1), f(n - 2), f(n - 3), …, f(1), f(0) recursion rule: f(n) = f(n - 1) + f(n - 2) = A + B base case: f(0) = 0, f(1) = 1 123456public long fib(int n) { if (n == 0 || n == 1) { return n; } return fib(n - 1) + fib(n - 2);} TC: (2n - 1) * T(node) = (2n - 1) * O(1) = O(2n - 1) = O(2n) SC: n * S(node) = n * O(1) = O(n) levels: ntotal number of nodes: 1 + 2 + 4 + … + 2n-1 = 2n - 1 number of branches = number of recursion calls = number of used subproblems leaf nodes = base cases one node = function call Example.2 Power ab method 1: loop TC: O(b) SC: O(1) method 2: recursionf(a, b) subproblem: f(a, b - 1), f(a, b - 2), … f(a, 0) recursion rule: f(a, b) = f(a, b - 1) * a base case: f(a, 0) = 1 123456public long power(int a, int b) { if (b == 0) { return 1; } return a * power(a, b - 1);} TC: O(b) SC: O(b) method 3: recursionf(a, b) subproblem: f(a, b /2), f(a, b / 4), …, f(a, 0) recursion rule: a. b is even: f(a, b) = f(a, b / 2)2 b. b is odd: f(a, n) = f(a, b / 2)2 * a base case: f(a, 0) = 1 123456789public long power(int a, int b) { if (b == 0) { return 1; } else if (b % 2 == 0) { return power(a, b / 2) * power(a, b / 2); } else { return power(a, b / 2) * power(a, b / 2) * a; }} TC: (1 + 2 + 4 + … + 2logb - 1) = (2logb - 1) * O(1) = (b - 1) * O(1) = O(b) SC: logb * O(1) = O(logb) 123456789101112public long power(int a, int b) { if (b == 0) { return 1; } long half = power(a, b / 2); if (b % 2 == 0) { return half * half; } else { return half * half * a; }} TC: total number of nodes * T(node) = logb * O(1) = O(logb) SC: logb * O(1) = O(logb) Recursion 与 1D or 2D Array 的结合Example.1. 1D Array二分法比较常见 MergeSort QuickSort Example.2.1 8 queen 1 Example.2.2 How to print 2D Array in spiral order. Recursion 与 LinkedList 的结合Example.1 Reverse a linked list. (pair by pair) 1234567891011ListNode reverseLinkedList(ListNode head) { if (head == null || head.next == null) { return head; } ListNode next = head.next; ListNode newHead = reverseLinkedList(head.next.next); head.next = newHead; next.next = head; return next;} Example.3 Reverse a binary tree upside down.Given a binary tree where all the right nodes are leaf nodes, flip it upside down and turn it into a tree left nodes. For example, turn these: 12345678910111213TreeNode reverseTree(TreeNode root) { if (root == null || root.left == null) { return root; } TreeNode newRoot = reverseTree(root.left); root.left.left = root.right; root.left.right = root; root.left = null; root.right = null; return newRoot;} Recursion 与 String 的结合Recursion 与 Tree 的结合Recursion + Tree 第一类问题：从下往上反值Example.1 How to store how many nodes in each node’s left-subtree?Example.2 Find the node with the max difference in the total number of descendents in its left subtree and right subtree. 123456789101112131415int maxDiffNode(TreeNode root, int[] globalMax, TreeNode[] solu) { if (root == null) { return 0; } int leftTotal = maxDiffNode(root.left, globalMax, solu); int rightTotal = maxDiffNode(root.right, globalMax, solu); if (Math.abs(leftTotal - rightTotal) &gt; globalMax[0]) { globalMax[0] = Math.abs(leftTotal - rightTotal); solu[0] = root; } return leftTotal + rightTotal + 1;} Example.3 Lowest Common Ancestor 1234567891011121314TreeNode LCA(TreeNode root, TreeNode a, TreeNode b) { // base case if (root == null || root == a || root == b) { return root; } TreeNode left = LCA(root.left, a, b); TreeNode right = LCA(root.right, a, b); if (left != null &amp;&amp; right != null) { return root; } return left == null ? right : left;} Example.4 Max Path Sum Binary Tree II (path from any node to any node)Given a binary tree in which each node contains an integer number. Find the maximum possible sum from any node to any node (the start node and the end node can be the same) What do you expect from your lchild / rchild? (usually it is the return type of the recursion funciton)(1) left: 直上直下的 path(2) right: 直上直下的 path What do you want to do in the current layer?sum of 人字形 path = left 的一撇 + right 的一捺 + root.value What do you want to report to your parent?root.value + Math.max(left, right) 123456789101112131415private int helper(TreeNode root, int[] max) { if (root == null) { return 0; } int left = helper(root.left, max); int right = helper(root.right, max); left = left &lt; 0 ? 0 : left; right = right &lt; 0 ? 0 : right; max[0] = Math.max(root.key + left + right, max[0]); return root.key + Math.max(left, right);} Recursion + Tree 第二类问题：Path Problem in Binary TreeRecursion + Tree 第三类问题：Tree Serialization ProblemSerialization pre in post level Recursion + Tree 第四类问题：Tree De-serialization ProblemQueueFIFO (first in first out) 先进先出 123Queue&lt;Integer&gt; queue = new LinkedList&lt;Integer&gt;();// also couldQueue&lt;Integer&gt; queue = new ArrayDeque&lt;Integer&gt;(); APIs: offer(): insert an element in the tail of queue poll(): get an element from the head of queue peek(): read the value of head element of queue size(): how many elements are in the queue isEmpty(): if this queue is empty StackLIFO (last in first out) 后进先出 123Deque&lt;Integer&gt; stack = new LinkedList&lt;Integer&gt;();// also couldDeque&lt;Integer&gt; stack = new ArrayDeque&lt;Integer&gt;(); APIs: offerFirst(): insert an element in the top of stack pollFirst(): get an element from the top of stack peekFirst(): read the value of top element stack size(): how many elements are in the stack isEmpty(): if this stack is empty or the size of this stack is 0 DequeFIFO &amp; LIFO APIs: offerFirst() / offerLast() pollFirst() / pollLast() peekFirst() / peekLast() Queue, Stack &amp; Deque 数据结构(逻辑层面) 内存里的存放方法 对应 java class 对应 java interface queue (FIFO) array / linked list ArrayDeque / LinkedList Queue stack (LIFO) array / linked list ArrayDeque / LinkedList Deque? deque array / linked list ArrayDeque / LinkedList Deque Queue and Deque are interfaces Common APIs Queue Type of operation throw exception return special value (null/false) insert add() offer() remove remove() poll() examine element() peek() element() is the method introduced by interface Queue, add() and remove() follows the definition of interface Collection add() and offer() return true when operation causes changes Deque Type of operation First Element Last Element throw exception return special value throw exception return special value insert addFirst() offerFirst() addLast() offerLast() remove removeFirst() pollFirst() removeLast() pollLast() examine getFirst() peekFirst() getLast() peekLast() All the operations’ cost is O(1) Stack by Linked ListHow to write an OOP? 根据 use case 设计 public API (包括 signature) 思考实现算法，写出 class field 实现 API，先实现最简单的，再实现比较复杂的 1234567891011121314151617181920212223242526272829303132333435363738394041424344class Stack { private ListNode head; private int length; public Stack() { } public Integer pop() { if (head == null) { return null; } ListNode node = head; head = head.next; length--; res.next == null; // best practice return node.value; } public Integer peek() { if (head == null) { return null; } return head.value; } public boolean push(int val) { ListNode newHead = new ListNode(val); newHead.next = head; head = newHead; length++; return true; } public int size() { return length; } public boolean isEmpty() { return length == 0; }} Queue by Linked List12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Queue { private ListNode head; private ListNode tail; private int length; public Queue() { } public Integer poll() { if (head == null) { return null; } ListNode node = head; head = head.next; if (head == null) { // check tail == null; } node.next == null; length--; return node.value; } public Integer peek() { if (head == null) { return null; } return head.value; } public boolean offer(int val) { if (head == null) { head = new ListNode(ele); tail = head; } else { tail.next = new ListNode(val); tail = tail.next; } length++; return true; } public int size() { return length; } public boolean isEmpty() { return length == 0; }} Queue by ArrayCircle Array (ring buffer): we can connect the start and end of the array, so that it is a cycle. 1234567891011121314151617181920212223242526272829303132333435363738class Queue { private int[] arr; private int head; private int tail; public Queue(int length) { arr = new int[length + 1]; tail = 1; } public boolean offer(int element) { if (isFull()) return false; arr[tail] = element; tail = (tail + 1) % arr.length; return true; } public Integer peek() { return isEmpty() ? null : arr[(head + 1) % arr.length]; } public Integer poll() { return isEmpty() ? null : arr[head = (head + 1) % arr.length]; } public int size() { int size = tail - head - 1; return size &lt; 0 ? size + arr.length : size; } public boolean isEmpty() { return (head + 1) % arr.length == tail; } public boolean isFull() { return head == tail; }} Linked ListListNode Class 的定义: 12345678class ListNode { public int value; // the storage value public ListNode next; // it is reference, or, it is an address public ListNode(int x) { this.value = x; }} ListNode1 -&gt; ListNode2 -&gt; ListNode3 -&gt; null key points: When you want to access value/next of a ListNode, make sure it is not null pointer. Never ever lose the control of the head pointer of the LinkedList. Array vs. LinkedList Memory Layout Array: consecutive allocated memory space, no overhead (额外开销) Linked List: non-consecutive, overhead of multiple objects with the “next” (Random) access time Example.1 Given a linked list, find the index - k element of it. 12345678910111213141516public class FindKth { public static ListNode findKIndex(ListNode head, int k) { if (head == null || k &lt; 0) { return null; } ListNode cur = head; int index = 0; while (index != k &amp;&amp; cur != null) { cur = cur.next; index++; } return cur; }} Example.2 How to find the middle node of a linked list ? 快慢指针法：slow 每次走一步，fast 每次走两步 1234567891011121314public ListNode findMidNode(ListNode head) { if (head == null) { return head; } ListNode slow = head; ListNode fast = head; while (fast.next != null &amp;&amp; fast.next.next != null) { slow = slow.next; fast = fast.next.next; } return slow;} Example.3 Insert a node in a sorted linked list. 1234567891011121314151617181920public ListNode insert(ListNode head, int value) { ListNode newNode = new ListNode(value); if (head == null) { return newNode; } if (head.value &gt;= value) { newNode.next = head; return newNode; } ListNode cur = head; while (cur.next ！= null &amp;&amp; cur.next.value &lt; value) { cur = cur.next; } newNode.next = cur.next; cur.next = newNode; return head;} Example.4 How to merge two sorted LinkedList into one long sorted LinkedList ? 1234567891011121314151617181920212223242526public ListNode merge(ListNode head1, ListNode head2) { ListNode dummyHead = new ListNode(0); ListNode cur1 = head1; ListNode cur2 = head2; ListNode curr = dummyHead; while (cur1 != null &amp;&amp; cur2 != null) { if (cur1.value &lt; cur2.value) { curr.next = cur1; cur1 = cur1.next; } else { curr.next = cur2; cur2 = cur2.next; } curr = curr.next; } if (cur1 == null) { curr.next = cur2; } if (cur2 == null) { curr.next = cur1; } return dummyHead.next;} TC: O(n) SC: O(1) Example.5 Remove nodes with target value in the LinkedList. 12345678910111213141516public ListNode removeNodes(ListNode head, int target) { ListNode dummyHead = new ListNode(0); dummyHead.next = head; ListNode pre = dummyHead; ListNode cur = head; while (cur != null) { if (cur.value == target) { pre.next = cur.next; } else { pre = cur; } cur = cur.next; } return dummyHead.next;} TC: O(n) SC: O(1) Example.6 Reverse a LinkedList. method 1: iterative 123456789101112public ListNode reverseIterative(ListNode head) { ListNode cur = head; ListNode pre = null; while (cur != null) { ListNode next = cur.next; cur.next = pre; pre = cur; cur = next; } return pre;} method 2: recursion subproblem: reverse(head) -&gt; reverse(head.next) base case: only 1 node or 0 node 1234567891011public ListNode reverseRecursion(ListNode head) { // base case if (head == null || head.next == null) { return head; } ListNode newHead = reverseRecursion(head.next); head.next.next = head; head.next = null; return newHead;} TC: O(n) SC: O(n) Sorting Algorithms Selection sort Merge sort Quick sort Bubble sort Bucket sort Patient sort Smooth sort Cocktail sort … Selection Sort sorted range: [0, i) unsorted range: [i, length - 1] stop condition: i &lt; n - 1 (we don’t have to process the last element) 1234567891011121314151617181920212223class SelectionSort { public void selectionSort(int[] arr) { if (arr == null || arr.length &lt; 1) { return; } for (int i = 0; i &lt; arr.length; i++) { int min = i; for (int j = i; j &lt; arr.length; j++) { if (arr[j] &lt; arr[min]) { min = i; } } swap(arr, i, min); } } private void swap(int[] arr, int x, int y) { int temp = arr[x]; arr[x] = arr[y]; arr[y] = temp; }} TC: O(n2) SC: O(1) Merge Sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253class MergeSort { public int[] mergeSort(int[] arr) { // corner case if (arr == null || arr.length &lt;= 1) { return arr; } return mergeSort(arr, 0, arr.length - 1); } private int[] mergeSort(int[] arr, int left, int right) { // base case if (left == right) { return new int[] {arr[left]}; } // subproblem int mid = left + (right - left) / 2; int[] leftRes = mergeSort(arr, left, mid); int[] rightRes = mergeSort(arr, mid + 1, right); // recursion rule return merge(leftRes, rightRes); } private int[] merge(int[] leftRes, int[] rightRes) { int[] res = new int[leftRes.length + rightRes.length]; int i = 0; int j = 0; int k = 0; while (i &lt; leftRes.length &amp;&amp; j &lt; rightRes.length) { if (leftRes[i] &lt; rightRes[j]) { res[k] = leftRes[i++]; } else { res[k] = rightRes[j++]; } k++; // res[k++] = leftRes[i] &lt; rightRes[j] ? leftRes[i++] : rightRes[j++]; } // case1: left res has some mot merge, right res doesn't // case2: right res has some mot merge, left res doesn't while (i &lt; leftRes.length) { res[k++] = leftRes[i++]; } while (j &lt; rightRes.length) { res[k++] = rightRes[j++]; } return res; }} subproblem: mergeSort(arr, left, mid), mergeSort(arr, mid + 1, right) recursion rule: merge(left, right) base case: left == right TC: O(n) + O(nlogn) = O(nlogn) SC: stack + heap = O(logn) + O(n) = O(n) Quick Sort1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class QuickSort { private Random random = new Random(); public void quickSort(int[] arr) { // corner case if (arr == null || arr.length &lt;= 1) { return; } quickSort(arr, 0, arr.length - 1); } public void quickSort(int[] arr, int left, int right) { // base case // [a] -&gt; left = right // [] -&gt; left &gt; right (pivot is the first or the last element of the array) if (left &gt;= right) { return; } // step 1: choose pivot // random.nextInt(x) -&gt; a random integer in [0, x) ------- // goal: a random number (pivot index) in [left, right] | // [left, right] -&gt; left + [0, right - left] | // -&gt; left + [0, right - left + 1) &lt;-------- int pivotIndex = left + random.nextInt(right - left + 1); swap(arr, pivotIndex, right); // step 2: partition int i = left; int j = right - 1; while (i &lt;= j) { if (arr[i] &lt; arr[right]) { i++; } else { swap(arr, j, i); j--; } } // step 3: put the pivot back swap(arr, i, right); // recursion rule quickSort(arr, left, i - 1); quickSort(arr, i + 1, right); }} TC: worst case: O(n2) average case: O(nlogn) SC: worst case: O(n) average case: O(logn) Rainbow SortDutch Flag Problem 荷兰旗问题 (only 3 kinds of numbers) 12345678910111213141516171819202122class RainbowSort { public void rainbowSort(int[] arr) { // corner case if (arr == null || arr.length &lt;= 1) { return; } int i = 0, j = 0, k = arr.length - 1; while (j &lt;= k) { if (arr[j] == 1) { swap(arr, i, j); i++; j++; } else if (arr[j] == 2) { j++: } else { swap(arr, j, k); k--; } } }} TC: O(n) SC: O(1) Binary Treeat most two children node 12345class TreeNode { int value; // the storage value TreeNode left; // by default = null TreeNode right; // by default = null} LeafNode: both rigth and left are null Tree Traverse: pre-order: current node before its subtress (self -&gt; left -&gt; right) in-order: current node in its subtrees (left -&gt; self -&gt; right) post-order: current node after its subtrees (left -&gt; right -&gt; self) Base Concept: Height of binary tree: The distance between the root with the deepest leaf node. Balanced binary tree: is commonly defined as a binary tree in which the depth (alse known as height) of the left and right subtrees of every node differ by 1 or less. for each of the nodes in this binary tree satisfyL the height of lesf subtree, right subtree at most diff by 1. If a tree has n number of nodes and it is balanced, the the heght (level of the tree = O(logn)). Complete binary tree: is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible. If a tree is a complete tree, then it must be a balanced tree. Binary Search Tree: for every single node in the tree, the values in its left subtree are all smaller than its value, and the values in its right subtree are all larger than its value. If we print the value of the nodes in BST in in-order sequence, then it must from an ascending order. Example.1 Get the height of a binary tree. 12345678910int getHeight(TreeNode root) { if (root == null) { return 0; } int leftHeight = getHeight(root.left); int rightHeight = getHeight(root.right); return Math.max(leftHeight, rightHeight) + 1;} Example.2 How to determine whether a binary tree is a balanced binary tree ? 1234567891011boolean isBalanced(TreeNode root) { if (root == null) { return true; } if (Math.abs(getHeight(root.left) - getHeight(root.right) &gt; 1) { return false; } return isBalanced(root.left) &amp;&amp; isBalanced(root.right);} Example.3 How to determine whether a binary tree is symmetric ? 1234567891011boolean isSymmetric(TreeNode left, TreeNode right) { if (left == null &amp;&amp; right == null) { return true; } else if (left == null || right == null) { return false; } else if (left.value != right.value) { return false; } return isSymmetric(left.left, right.right) &amp;&amp; isSymmetric(right.left, left.right);} TC: O(n) SC: O(height) Example.4 LCAGiven two nodes in a binary tree (with parent pointer available), find their lowest common ancestor. There is parent pointer for the nodes in the binary tree The given two nodes are not guaranteed to be in the binary tree 1234567891011121314151617181920212223242526272829303132333435363738class Solution { public TreeNode findLCA(TreeNode one, TreeNode two) { if (one == null || two == null) { return null; } int depth1 = getDepth(one), depth2 = getDepth(two); if (depth1 &gt; depth2) { return findLCA(one, two, depth1 - depth2); } else { return findLCA(two, one, depth2 - depth1); } } private int getDepth(TreeNode node) { int depth = -1; while (node != null) { depth++; node = node.parent; } return depth; } private TreeNode findLCA(TreeNode longer, TreeNode shorter, int diff) { while (diff &gt; 0) { longer = longer.parent; diff--; } while (longer != shorter) { longer = longer.parent; shorter = shorter.parent; } return longer; }} Binary Search Tree (BST)For every single node in the tree, the values in its left subtree are all smaller than its value, and the values in its right subtree are all larger than its value. search() - O(h), worst case O(n), best O(logn) insert() - O(h), worst case O(n), best O(logn) remove() - O(h), worst case O(n), best O(logn) Example.1 Search in BST. method 1: iteration 123456789101112TreeNode search(TreeNode root, int target) { TreeNode cur = root; while (cur != null &amp;&amp; cur.value != targer) { if (target &lt; cur.value) { cur = root.left; } else { cur = root.right; } } return cur;} TC: O(h) SC: O(1) method 2: recursion 123456789101112// tail recursionTreeNode search(TreeNode root, int target) { if (root == null || root.value == target) { return root; } if (target &lt; root.value) { return search(root.left, target); } return search(root.right, target);} TC: O(h) Example.2 Insert in BST. method 1: iteration 123456789101112131415161718192021222324TreeNode insert(TreeNode root, int targer) { if (root == null) { return new TreeNode(targer); } TreeNode cur = root; TreeNode pre = null; while (cur != null) { if (target &lt; cur.value) { if (cur.left != null) { cur = cur.left; } else { cur.left = new TreeNode(target); break; } } else { if (cur.right != null) { cur = cur.right; } else { cur.right = new TreeNode(target); } } } return root;} method 2: recursion 123456789101112TreeNode insert(TreeNode root, int targer) { if (root == null) { return new TreeNode(target); } if (target &lt; root.value) { root.left = insert(root.left, target); } else if (target &gt; root.value) { root.right = insert(root.right, target); } return root;} Example.3 Delete in BST. case 1: The node to be deleted has no child case 2: The node to be deleted has no left child case 3: The node to be deleted has no right child case 4: The node to be deleted has both left and right child. We need to move some nodes from left / right subtree to replace it. case 4.1: node.right does not have left child, meaning itself is the smallest node in this case, we just move node.right up case 4.2: node.right has left child, we need to find the smallest node, and move it up 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Solution { public TreeNode delete(TreeNode root, int target) { if (root == null) { return null; } // find target node if (root.value &gt; target) { root.left = delete(root.left, target); return root; } else if (root.value &lt; target) { root.right = delete(root.right, target); return root; } //guarantee root != null &amp;&amp; troot.value == target if (root.left == null) { // case 1&amp;2 return root.right; } else if (root.right == null) { // case 3 return root.left; } //guarantee root.left != null &amp;&amp; rot.right != null //case 4.1 if (root.right.left == null) { root.right.left = root.left; return root.left; } //case 4.2 // 1. find and delete smallest node in root right TreeNode smallest = deleteSmallest(root.right); // connect the smallest node with root.left and root.right smallest.left = root.left; smallest.right = root.right; // return the smallest node return smallest; } private TreeNode deleteSmallest(TreeNode cur) { TreeNode prev = cur; cur = cur.left; while (cur.left != null) { prev = cur; cur = cur.left; } // cur is the smallest one, and prev is its parent // Invariance: cur (prev.left) does not have left child prev.left = prev.left.right; // cur.right return cur; }} TC: O(h) find(upper part of height) + findSmallest(lower part of height) SC: O(h) on call stack GraphGeneral TreeEach node can have an arbitrary number of children 12345678class TreeNode { int key; List&lt;TreeNode&gt; children; public TreeNode(int key) { this.key = key; children = new ArrayList&lt;TreeNode&gt;(); }} We use the root to represent the general tree. G = V + E GraphTree is a special kind of Graph 12345678class GraphNode { int key; List&lt;GraphNode&gt; neighbors; public GraphNode(int key) { this.key = key; neighbors = new ArrayList&lt;GraphNode&gt;(); }} We use the List&lt;GraphNode&gt; to represent the general tree. Heap &amp; Graph Search AlgorithmsHeap堆，亦被称为优先队列 用途： 维护一个变化的数据集的最优值 性质： 堆的数显通过构造二叉堆 (binary heap)， 这种数据结构具有以下性质 堆总是一颗完全二叉树 (complete binary tree) 根节点最小的堆叫做MIN HEAP，根节点最大的堆叫做MAX HEAP MIN HEAP: 任意节点小于(等于) 它的所有后裔 (descendent) (堆序性) MAX HEAP: 任意节点大于(等于) 它的所有后裔 (descendent) (堆序性) Index of parent = i, what is the index of the two child nodes? left child of index i = 2 * i + 1 right child of index i = 2 * i + 2 parent of index i = (i - 1) / 2 Operations: insert: 向堆中插入一个新元素；TC: O(logn) update: 将新元素提升使其符合堆的性质；TS: O(logn) get / top: 获取当前堆顶元素的值；TC: O(1) pop: 删除堆顶元素；TC: O(logn) heapify: 使得一个 unsorted array 变成一个堆；TC:O(n) Example. Find smallest k elements from an unsorted array of size n. method 1: sort TC: O(nlogn) method 2: min heap Heapify all elements -&gt; O(n) Call pop() k times to get the k smallest elements -&gt; O(klogn) TC: O(n + klong) method 3: max heap Heapify the first k elements to form a MAX HEAP of size = k -&gt; O(k)Alternatively, call insert() k times instead of heapify -&gt; O(klogk) Iterate over the reaining (n - k) elements one by one.When we tracerse a new element:compare with the largest element of the previous smallest k candidates case 1: new element &gt;= top: ignore case 2: new element &lt; top: update (top -&gt; new element)O((n - k)logk) TC: O(k + (n - k)logk) Breadth-First Search (BFS-1)BFS 的操作过程 &amp; How to describe a BFS’s action during an interview? Data Structure: Maintain a FIFO queue, put all traversed nodes that haven’t been expanded. Initial state Expand a node Generate s’s neighbor nodes: reach out to its neighboring nodes termination condition: do a loop until the queue is empty Optionally deduplicate visited nodes (typically for graph not for tree) Best First Search (BFS-2) Usages: Find the shortest path cost from a single node (source node) to any other nodes in that graph (点到面(==所有点)的最短距离算法) Data Structure: PriorityQueue (minHeap) 解题思路 Initial state: (start node) Node expansion / Generation rule Termination condition: 所有点都计算完毕才停止 -&gt; PriorityQueue 为空 Heap in Java (PriorityQueue)PriorityQueueIt is a heap with same Queue interface with offer(), peek(), poll().But, it is not FIFO, when poll() or peek() we always look at the smallest / largest element (min heap / max heap).Internally it is implemented using an array. 概念区分 数据结构 (逻辑层面) 内存里的存放方法 对应 java class 对应 java interface queue (FIFO) array / linked list ArrayDeque / LinkedList Queue stack (LIFO) array / linked list ArrayDeque / LinkedList Deque deque (double-ended) array / linked list ArrayDeque / LinkedList Deque heap (tree like) array (abstract tree) PriorityQueue Queue OrderThe PriorityQueue need to know how to compare the elements and determine which one is smaller / larger. The element type implementing Comparable interfaceThe element’s class can implement Comparable interface and thus implement the required method compareTo(), PriorityQueue will use this method to compare any tow elements. 123interface Comparable&lt;E&gt; { int compareTo(E ele);} 12345678910111213141516// part of the Integer class implementation...class Integer implements Comparable&lt;Integer&gt; { private int value; public Integer(int value) { this.value = value; } @Override public int compareTo(Integer another) { if (this.value == another.value) { return 0; } return this.value &lt; another.value ? -1 : 1; }} Provide an extra Comparator object to compare the elementsThere is another interface Compartor, it is used to compare two elements with same type E. 123interface Comparator&lt;E&gt; { int compare(E o1, E o2);} 1234567891011121314151617181920class Cell { public int row; public int col; public int value; public Cell(int row, int col, int value) { this.row = row; this.col = col; this.value = value; }}class MyComparator implements Comparator&lt;Cell&gt; { @Override public int compare(Cell c1, Cell c2) { if (c1.value == c2.value) { return 0; } return c1.value &lt; c2.value ? -1 : 1; }} MIN HEAP &amp; MAX HEAPThere is a utility method Collections.reverseOrder(), it will return a comparator that reverses the natural order. 12345// min heapPriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;();// max heapPriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); Most frequently used constructors of PriorityQueue PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(); initialize the internal array with default capacity(11) class Cell must implements Comparable&lt;Cell&gt; PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(16); initialize the internal array with specified capacity(16) class Cell must implements Comparable&lt;Cell&gt; PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(16, new MyComparator()); initialize the internal array with specified capacity(16) class MyComparator must implements Comparator&lt;Cell&gt; PriorityQueue&lt;Cell&gt; heap = new PriorityQueue&lt;Cell&gt;(new MyComparator()); class MyComparator must implements Comparator&lt;Cell&gt; Java 8+ Nested ClassesA class within another class: It is a way of logically grouping classes that are only used in one place It increases encapsulation It can lead to more readable and maintainable code 123456class LinkedList { // Nested class class ListNode { // ... }} Anonymous inner class (define in a method with just new and no definition)1234567891011class Solution { PriorityQueue&lt;Cell&gt; pQueue = new PriorityQueue&lt;&gt;(16, new Comparator&lt;Cell&gt;() { @Override public int compare(Cell c1, Cell c2) { if (c1.value == c2.value) { return 0; } return c1.value &lt; c2.value ? -1 : 1; } })} 实现一个接口 定义一个类 创建一个 instance call constructor Similar to: 1234567891011class MyComparator implements Comparator&lt;Cell&gt; { @Override public int compare(Cell c1, Cell c2) { if (c1.value == c2.value) { return 0; } return c1.value &lt; c2.value ? -1 : 1; }}PriorityQueue&lt;Cell&gt; pQueue = new PriorityQueue&lt;&gt;(16, new MyComparator()) Lambda (Java 8) 12345678PriorityQueue&lt;Cell&gt; pQueue = new PriorityQueue&lt;&gt;(16, (Cell c1, Cell c2) -&gt; { if (c1.value == c2.value) { return 0; } return c1.value &lt; c2.value ? -1 : 1; }) Example. Smallest k elements in unsorted array.Find the K smassles numbers in an unsorted integer array A. The returned numbers should method 1: MIN HEAP 12345678910111213141516171819public int[] findKSmallest(int[] arr, int k) { if (k &gt; arr.length) { return null; } PriorityQueue&lt;Integer&gt; minHeap = new PriorityQueue&lt;Integer&gt;(); // TC: O(nlogn) for (int num: arr) { minHeap.offer(num); } int[] res = new int[k]; // TC: O(klogn) for (int i = 0; i &lt; k; i++) { res[i] = minHeap.poll(); } return res;} TC: O(nlogn) + O(klogn) = P(nlogn) method 2: MAX HEAP 12345678910111213141516public int[] findKSmallest(int[] arr, int k) { if (k &gt; arr.length) { return null; } PriorityQueue&lt;Integer&gt; maxHeap = new PriorityQueue&lt;Integer&gt;(Collections.reverseOrder()); for (int i = 0; i &lt; k; i++) { maxHeap.offer(arr[i]); } int[] res = new int[k]; for (int i = 0; i &lt; k; i++) { res[i] = minHeap.poll(); } return res;} TC: O((n + k)logk) Implementing HeapsBasic Heap Internal OperationspercolateUp() When to use?The element need to be moved up to maintain the heap’s property, for example, when offering a new element into the heap. How?Compare the element with its parent, move it up when necessary, do this until the element does not need to be moved. TC: O(logn) percolateDown() When to use?The element need to be moved down to maintain the heap’s property, for example, when poll the root element from the heap. How?Compare the element with its two children, if the smallest one of the two children is smaller than the element, swap the element with that child, do this until the element does not need to be moved. TC: O(logn) heapiyf() Convert an array into a heap in O(n) time. How?For each node that has at least one child, we perform percolateDown action, in the order of from the nodes on the deepest level to the root. TC: O(n) 原理： 当一个 node 左子树和右子树都是堆，对它本身做 percolateDown，会使得以它为 root 的整颗子树成为堆。 The range of indices nees to perform percolateDown is: [0, n / 2 - 1]Last non-leaf node: parent of last node index = ((n - 1) - 1) / 2 = n / 2 - 1 update() If you know the position of the element you want to update, it will take O(logn) How?Either you need percolateUp, or percolateDown on that element Waht if you do not know the position of the element?You need to find the position of the element first, if not asking for help with other additional data structure, this operation is O(n) Implementation of Min Heap123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118public class MinHeap { private int[] array; private int size; public MinHeap(int[] array) { if (array == null || array.length == 0) { throw new IllegalArgumentException(&quot;input array can not be null or empty&quot;); } this.array = array; size = array.length; heapify(); } private void heapify() { for (int i = size / 2 - 1; i &gt;= 0; i--) { percolateDown(i); } } public MinHeap(int cap) { if (cap &lt;= 0) { throw new IllegalArgumentException(&quot;capacity can not be &lt;= 0&quot;); } array = new int[cap]; size = 0; } public int size() { return size; } public boolean isEmpty() { return size == 0; } public boolean isFull() { return size == array.length; } private void percolateUp(int index) { if (index &lt; 0 || index &gt;= size) { return; } while (index &gt; 0) { int parent = (index - 1) / 2; if (array[parent] &gt; array[index]) { swap(parent, index); } else { break; } index = parent; } } private void percolateDown(int index) { while (index &lt;= size / 2 -1) { int left = index * 2 + 1; int right = index * 2 - 1; int toSwap = left; if (right &lt; size &amp;&amp; array[left] &gt;= array[right]) { toSwap = right; } if (array[index] &gt; array[toSwap]) { swap(index, toSwap); } else { break; } index = toSwap; } } public Integer peek() { if (size == 0) { return null; } return array[0]; } public Integer poll() { if (size == 0) { return null; } int res = array[0]; array[0] = array[size - 1]; size--; percolateDown(0); return res; } public void offer(int ele) { if (size == array.length) { array = Arrays.copyOf(array, (int)(array.length * 1.5)); } array[size] = ele; size++; percolateUp(size - 1); } public int update(int index, int ele) { if (index &gt; array.length || index &lt; 0) { throw new ArrayIndexOutOfBoundsException(&quot;Invalid index range&quot;); } int oldVal = array[index]; array[index] = ele; if (ele &lt; oldVal) { percolateUp(index); } else { percolateDown(index); } return oldVal; } private void swap(int l, int r) { int temp = array[l]; array[l] = array[r]; array[r] = temp; }} Graph Search Algorithms - DFS(Depth-First Search)DFS 基本方法： What does it store on each level? How many different states should we try to put on this level? Example.1 Find subset.E.g. Print all subsets of a set Set = {‘a’, ‘b’, ‘c’} What does it store on each level?Three levels. For each level, it makes the decision on whether to put this element into the final set. How many different states should we try to put on this level?Two different states, each state(case) considers either select or not select 1234567891011121314void findSubset(char[] input, int index, StringBuilder solutionPrefix) { if (index == input.length) { System.out.println(solutionPrefix); return; } // case 1: add inut[index] to the solution prefix solutionPrefix.append(input[index]); finSubset(input, index + 1, solutionPrefix); solutionPrefix.deleteCharAt(solutionPrefix.length() - 1); // case 2: do not add input[index] to the solution prefix findSubset(input, index + 1, solutionPrefix);} TC: O(2n) SC: O(n) on heap + O(n) on call stack = O(n) Example.1.1 Insert empty space.We can choose to insert either one or zero empty space between each paire of adjacent letters. Please print out all possible results. 1 Example.2 Find all valid permutation using the parenthesis provided. What does it store on each level?Six levels, each level considers one position (in which there will be onle one parenthesis added in this position). How many different states should we try to put on this level?Two states,either left or right parenthesis. 1234567891011121314151617181920void DFS(int n, int l, int r, StringBuilder solutionPrefix) { if (l == n &amp;&amp; r == n) { System.out.println(solutionPrefix); // base case return; } // case 1: add '(' on this level if (l &lt; n) { solutionPrefix.append('('); DFS(n, l + 1, r, solutionPrefix); solutionPrefix.deleteCharAt(solutionPrefix.length() - 1); } // case 2: add '(' on this level if (l &gt; r) { solutionPrefix.append(')'); DFS(n, l, r + 1, solutionPrefix); solutionPrefix.deleteCharAt(solutionPrefix.length() - 1); }} TC: O(22n) SC: O(2n) = O(n) Example.3 Print all combinations of coins that can sum uo to total value n.E.g. total value n = 99 centscoin value = 25 10 5 1 cent What does it store on each level?Four levels, each level considers on type of coin How many different states should we try to put on this level?Dynamically changes 1234567891011void findCombination(int[] coin, int moneyLeft, int index, int[] sol) { if (index == coin.length - 1) { sol[index] = moneyLeft; // print solution and return } for (int i = 0; i &lt;= moneyLeft / coin[index]; i++) { sol[index] = i; findCombination(coin, moneyLeft - i * coin[index], index + 1, sol); }} TC: O(kn) Example.4 Given a string with no duplicate letters, how to print out all permutations of the string. What does it store on each level?Three levels, each level represents on position How many different states should we try to put on this level?Rmaining unused letter 12345678910111213void permutation(char[] input, int index) { if (index == input.length) { System.out.println(input); return; } // put each letter in the index-th position of the input str for (int i = index; i &lt; input.length; i++) { swap(input, index, i); permutation(input, index + 1); swap(input, index, i); }} TC: O(n!) SC: O(n) Conclusion: whenever every single permutation contains all elements in the initial input, the we should consider SWAP and SWAP Set, Map &amp; StringSetA collection that can not contain duplicate elements. HashSet: Which stores its elements in a hashtable, is the best-performing implementation, however it makes no guarantees concerning the order of iteration. TreeSet: Which stores it elements in a red-black tree (balanced binary search tree), orders its elements based on their value LinkedHashSet: It is a HashSet and also it is a LinkedList, it maintains the order when each of the elements is inserted into the HashSet MapA collection that maps keys to values. A Map cannot contain duplicate keys; each key can map to one value. HashMap TreeMap LinkedHashMap HashMapCommon API V put(K key, V value) V get(Object key) V remove(Object key) boolean containsKey(Object key) boolean containsValue(Object value) void clear() int size() boolean isEmpty() Time Complexity Operation Average Worst (&lt;= JDK 7) search: boolean containsKey(Object key) V get(Object key) O(1) O(n) insert / update: V put(K key, V value) O(1) O(n) delete: V remove(Object key) V get(Object key) O(1) O(n) HashMap Implementation Collision Control Collision - two keys mapped to the same bucket Separate Chaining (Close Addressing) - the element of each of the buckets is actually a single linked list. Open addressing - put the key-value pair into the “next” available bucket. How to define next? Linear/quadratic/exponential probing, hash again Challenge: handling removed keys in the map (mark deleted) Not used by Java; but by some real life systems. If different Keys are determined to use the same bucket, they will be chained in the list. define the class for each entry 123456789101112131415161718192021class Node&lt;K, V&gt; { private final K key; private V value; Node&lt;K, V&gt; next; Node(K key, V value) { this.key = key; this.value = value; } public K getKey() { return key; } public V getValue() { return value; } public void setValue(V value) { this.value = value; }} Maintain an array of entriesNode&lt;K, V&gt;[] array; Hash(key) to get the hash# 12345678private int hash(K key) { // return the hash# of the key if (key == null) { return 0; } int hashNumber = key.hashCode(); return hashNumber &amp; 0x7FFFFFFF;} From the hash#, mapped to the entry index. 1234int getIndex(int hashNumber) { // reutrn the corresponding index of array return hashNumber % array.length;} When iterate the corresponding entry for the given key, which is actually a singly linked list, we need compare each of the entry in the list, if the key is the same as the key we want. 1234567Node&lt;k, V&gt; cur = array[index];while (cur != null) { K curKey = cur.getKey(); if (curKey is the same as given key) { //... }} Implementation: APIs: put, get, remove, size, isEmpty Fields: array[], size Constructor: capacity, load factor (threshold), no parameter TODO: 123456789class HashMap&lt;K, V&gt; { private int size; private Node[] buckets; private double loadFactor; HashMap() { }} StringExample.1 Remove a/some particular chars from a string in placeE.g. string input = “student”, remove “u” and “n” -&gt; output: “stdet” (in place) 快慢指针，同向而行 12345678910void removeChar(StringBuilder input) { int slow = 0; for (int fast = 0; fast &lt; input.length; fast++) { if (input.charAt(fast) != 'u' &amp;&amp; input.charAt(fast) != 'n') { input.setCharAt(slow, input.charAt(fast)); slow++; } } input.delete(slow, input.length);} Example.2 Remove all leading/trailing and duplicate empty spaces (only leave onw empty space if duplicated spaces happen) from the input string. (must in place)E.g. input = “___abc_de___“ -&gt; output = “abc_de” 1 Example.2.1 Remove duplicated and adjacent letters (leave only one letter in each duplicated section) in a stringE.g. input = “aabbbbazw” -&gt; output = “abazw” 1 Example.2.2 Char de-duplication adjacent letters repeatedlyE.g. input = “abbbazw” -&gt; output = “zw” method 1: Stack 1 method 2: slow &amp; fast 1 Example.3 Sub-string FindingHow to determine whether a string is a substring of another string. 1234567891011121314151617181920public int subStr(String text, String pattern) { if (text == null || pattern == null || text.length() &lt; pattern.length()) { return -1; } if (pattern.length() == 0) { return 0; } // i is every possible start index in text to test for (int i = 0; i &lt;= text.length() - pattern.length(); i++) { int j = 0; while (j &lt; pattern.length() &amp;&amp; text.charAt(i + j) == pattern.charAt(j)) { j++; } if (j == pattern.length()) { return i; } } return -1;} TC: O(n2) Example.4 String ReversalM1: iteration 1 M2: recursion 1 Example.4.1 Reverse the word.E.g. input = “I love yahoo” -&gt; output = “yahpp love I” M1step1: Reverse the whole sentence.step2: Reverse every single word. 1 Example5.Char ReplacementE.g. input = “student” -&gt; output = “stuxxt” (den -&gt; xx) 1 What if we do not know the size relationship between s1 and s2?case 1: s1.length() &gt;= s2.length()case 2: s1.length() &lt; s2.length() Advanced Topics Shuffling permutation Decoding/encoding Sliding windows using slow/fast pointers String ShufflingExample.1 “A1B2C3D4E5” -&gt; “ABCDE12345” 1 Example.2 “ABCDE12345” -&gt; “A1B2C3D4E5” Example.3 “ABCDEFG1234567” -&gt; “ABC123DEFG4567” 1234567891011121314151617void convert(char[] a, int left, int right) { // base case if (rigth - left &lt;= 1) { return; } int size = right - left + 1; int mid = left + size / 2; int leftMid = left + size / 4; int rightMid = left + size * 3 / 4; reverse(a, leftMid, mid - 1); reverse(a, mid, rightMid - 1); reverse(a, leftMid, rightMid - 1); convert(a, left, left + 2 * (leftMid - left) - 1); convert(a, left + 2 * (leftMid - left), right);} String permutationExample.1 No duplicate letters in the input string.Solution: DFS Example.2 Maybe duplicate letters in the input string.We need to avoid the same type of letter to be swapped to the index-th position more than once (under the same parent node) 1 String En/DecodingExample.1 String EncodingE.g. input = “aaaabccaaaa5” -&gt; output = “a4b1c2a5” step 1: From left to right, deal with the cases where the adjacent occurrence of the letters &gt;= 2, which will make the original string shorter, in the meantime record the count of single letters and keep it as it was.step 2: Calculate extra space we need for single letters, resize string.step 3: From right to left, deal with single letters. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution { public String strEncoding(String str) { if (str == null || str.isEmpty()) { return str; } char[] arr = str.toCharArray(); return encoding(arr); } private String encoding(char[] input) { // step1 &amp; step2 int slow = 0, fast = 0; int newLength = 0; while (fast &lt; input.length) { int begin = fast; while (fast &lt; input.length &amp;&amp; input[fast] == input[begin]) { fast++; } input[slow++] = input[begin]; if (fast - begin == 1) { newLength += 2; } else { int len = copyDigits(input, slow, fast - begin); slow += len; newLength += len + 1; } } // step 3 char[] res = new char[newLength]; fast = slow - 1; slow = newLength - 1; while (fast &gt;= 0) { if (Character.isDigit(input[fast])) { while (fast &gt;= 0 &amp;&amp; Character.isDigit(input[fast])) { res[slow--] = input[fast--]; } } else { res[slow--] = '1'; } res[slow--] = input[fast--]; } return String(res); } private int copyDigits(char[] input, int index, int count) { int len = 0; while (int i = count; i &gt; 0; i /= 10) { index++; len++; } while (int i = count; i &gt; 0; i /= 10) { int digit = i % 10; input[--index] = digit; } return len; }} Sliding window in a string (slow + fast indices)Example.1 Longest substring that contains only unique charGiven a string , returns the length of the longest substring without duplicate characters. Example.2 Find all anagrams(同形异构体) of a substring S2 in a long string S1. M1: use two hashMap 1 M2: use one hashMapWe only use one hashMap t store the information of S2. 1 Example.3 Givena 0-1 array, you can flip at most k ‘0’s to ‘1’s. Find the longest subarray that consists of all ‘1’s.It’s actually a sliding window problem. Bit Representation &amp; Bit OperationsBit Operations (TC: O(1)) bitwise AND (&amp;) 1234567 0b11001110 (-50)&amp; 0b10011000 (-104)= 0b10001000 (-120)byte a = -50;byte b = -104;byte c = a &amp; b; // c = -120 bitwise OR (|) NOT (~) a = 5 = 0b00000101 b = ~a = 0b11111010 -a = (~a) + 1, if a &gt;= 0 XOR (^) 00 -&gt; 0 11 -&gt; 0 01 or 10 -&gt; 1 123 0b11001110 (-50)^ 0b10011000 (-104)= 0b01010110 (86) x ^ y = y ^ x x ^ (y ^ z) = (x ^ y) ^ z x ^ x = 0 x ^ 0 = x left shift (&lt;&lt;) 右侧补充零 right shift (&gt;&gt;) 正数左侧补充零，负数左侧补充 1 Building BlocksGiven an integer x, test whether x’s k-th bit is one. (bit tester) 1234567891011int x = 0b b7 b6 b5 b4 b3 b2 b1 b0_x = 0b b7 b7 b7 b6 b5 b4 b3 b2 (x &gt;&gt; k)&amp; = 0b 0 0 0 0 0 0 0 1 = 0b 0 0 0 0 0 0 0 0if ((x &gt;&gt; k) &amp; 1 == 0) { // b2 is 0} else { // b2 is 1} Given an integer x, how to set x’s k-th bit to 1? (bit setter) 123456// k = 2int x = 0b b7 b6 b5 b4 b3 b2 b1 b0| = 0b 0 0 0 0 0 1 0 0 (1 &lt;&lt; k) = 0b b7 b6 b5 b4 b3 1 b1 b0int res = x | (1 &lt;&lt; k); Given an integer x, how to set x’s k-th bit to 0? (bit resetter) 123456// k = 2int x = 0b b7 b6 b5 b4 b3 b2 b1 b0&amp; = 0b 1 1 1 1 1 0 1 1 (~0b00000100) = ~(1 &lt;&lt; k) = 0b b7 b6 b5 b4 b3 0 b1 b0int res = x &amp; ~(1 &lt;&lt; k); Example.1 Determine whether an integer x is a power of 2. 123456789101112boolean isPowerTwo(int x) { return (x &gt; 0) &amp;&amp; (x &amp; (x - 1) == 0);}// debug// 2的幂次x = 0b 00010000x - 1 = 0b 00001111// 不是2的幂次x = 0b 00010010x - 1 = 0b 00010001 Example.2 How to determine the number of bits that are different between two integers? 1234567int numberOfDifferentBits(int a, int b) { int count = 0; for (int c = a ^ b; c != 0; c = c &gt;&gt; 1) { count += (c &amp; 1); } return count;} Example.3 Conversion between signed and unsigned, bit extension and bit truncation. Example.4 Determine whether a string contains unique characters.M1: HashSet 12345678910boolean hasUnique(String str) { HashSet&lt;Character&gt; set = new HashSet&lt;Character&gt;(); for (int i = 0; i &lt; str.length(); ++i) { if (set.contains(str.charAt(i))) { return false; } set.add(str.charAt(i)); } return true;} TC: O(1) SC: O(1) M2: boolean[] 123456789101112boolean hasUnique(String str) { // assume ASCII // set[i] 表示ascii为i的字符是否出现过 boolean[] set = new boolean[256]; for (int i = 0; i &lt; str.length(); ++i) { if (set[str.charAt(i)]) { return false; } set[str.charAt(i)] = true; } return true;} TC: O(1) SC: O(1) M3: bit 1234567891011121314151617boolean hasUnique(String str) { // int set = 0b b31 b30 b29 ... b0 // b0 代表 'a' 是否出现 // b1 代表 'b' 是否出现 // ... // b25 代表 'z' 是否出现 int set = 0; for (int i = 0; i &lt; str.length(); ++i) { int k = a.charAt(i) - 97; if ((set &gt;&gt; k) &amp; 1 == 1) { return false; } // bit setter set = set | (1 &lt;&lt; k); } return true;} Example.5 How to reverse all bits of a numver? 123void reverseBits(int num) {} Example.6 Given a non-negative integer x, how to get the hexadecimal representation of the number in string type? M1: 除模 12345678910111213141516String toHex(int num) { if (num == 0) { return &quot;0x0&quot;; } char[] base = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E','F'}; StringBuilder sb = new StringBuilder(); while (num &gt; 0) { int remainder = num % 16; num = num / 16; sb.append(base[remainder]); } sb.append(&quot;x0&quot;); sb.reverse(); return sb.toString();} M2: 四位二进制变为一位十六进制 12345678910String toHex(int num) { char[] base = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'}; StringBuilder sb = new StringBuilder(); for (int maskEnd = 28; maskEnd &gt;= 0; maskEnd -= 4) { char digit = base[(num &gt;&gt; maskEnd) &amp; 0xF]; sb.append(digit); } return sb.toString();} Bit Representation for Integers min max count 原码(true) 1111 (-7) 0111 (7) 15 反码(one’s complement) 1000 (-7) 0111 (7) 15 补码(two’s complement) 1000 (-8) 0111 (7) 16 one’s complement can only represent -(2N-1 - 1) to (2N-1 - 1) unding N bitstwo’s complement can represent -2N-1 to 2N-1 using N bits “&gt;&gt;&gt;” vs. “&gt;&gt;” unsigned shift “&gt;&gt;&gt;” - logical signed shift “&gt;&gt;” - arithmetical Autoboxing &amp; Unboxing Autoboxing is the automatic conversion that the Java complier makes between the primitive types and their corresponding object wrapper classes. Unboxing is the reverse operation of autoboxing. Dynamic Programming核心思想 把一个大问题 (size == n) 的解决方案用比他小的问题来解决，也就是思考从问题 size = n - 1 增加到 size = n 的时候，如何用小问题的 solution 构建大问题的 solution。 与 recursion 的关系： Recursion 从大到小来解决问题，不记录任何 sub-solution 只要考虑 base case recursion rule DP 从小到大来解决问题，记录 sub-solution base case 由 size (&lt; n) 的 sub-solution(s) -&gt; size (n)的 solution When to use DP vs. DFS? You are required to print out ALL possible permutations -&gt; DFS You are required to ONLY return the final 1 number (min / max cut numbers) Linear scan and look back (80% questions)Example.1 Largest sum of subarrayGiven an array, find the subarray that has the greatest sum. Return the sum. base case: M[0] = input[0] induction rule: M[i] represents [from 0-th index to i-th index] the largest sum of subarray, must include the i-th index M[i] = M[i - 1] + input[i] (if M[i - 1] &gt;= 0)input[i] (else) 123public int largestSum() {}","link":"/2021/07/09/Algorithm/"},{"title":"System Design","text":"IntroductionSystem Design is the process of defining the architecture, modules, interfaces, and data for a system to satisfy specified requirements. requirements functional non-functional architecture modules interfaces data System Design InterviewDesign a product, or a feature of a product (mostly web applications) availability scalability vs. extendsibility performance reliability CAP (consistency, availability, partition tolerance) robustness cost … How can I do well in a system design Interview? Understand the goal Scenarious and Use-cases Ask the right questions Clarify the problem you need to solve Functional vs. Non-Functional Understand the scope How many DAU(daily active users) What is the QPS level? Start with the Big-picture, then Drill-down Done is better than perfect Provide a functional solution Simplify the priblem and provide a straw-man design Web application and data storage Reiterate and optimize Availability Scalability Bottlenecks Single point failures … Trade-offs Make it easy for the Interviewr to put down your positive points Keep system scaling, performance, and availability in mind Web Application典型架构 Client 与用户的交互 内容呈现 功能的体现 用户输入 (文字、图形、其他…) 与后端的信息交流, HTML, XML, JSON 数据的本地缓存 与其他终端应用的交互，如 Map, Phone call HTTP (Hypertext Transfer Protocol) Server HTTP Server 是用于处理和响应终端的 HTTP 请求的，然后根据不同请求的需求，分发到相应的应用服务器 (Application Server) Application Server An application server is a software framework that provides both facilities to create web applications and a server environment to run them. Storage 存储数据 文件系统：网络文件系统 GFS 数据库：关系数据库 (MySQL, MSSQL, Oracle)，非关系数据库，SQL 系统间的通信 域名解析, DNS 应用层协议, HTTP, Client 与 HTTP Server 的信息交互 HTTP Request 操作类型. GET, POST, PUT, DELETE HTTP Response Code. 200, 300, 4xx, 5xx … 应用层协议是建立在网络通信协议之上的 TCP (Transmission Control Protocol) 传输控制协议 可靠的端到端协议通信协议 三次握手, SYN, SYN ACK, ACK 四次挥手 UDP IP Internet Protocol 寻址 完成数据包点对点的寻址和传输 不保证数据包已被接受 主要的涉及到性能改进的技术和部分Load Balancer 分流，分配工作 保证服务器不过载 当新服务加入，可自动分配，同理，当服务器被移除，或者 fail，取消分配请求 Caches 提高数据获取速度 降低数据服务器的负载 增加了写的开销 Indexing 用于更快的访问数据 更多的时候用于数据库 牺牲存储空间和写的速度换取更快的读的速度 Bandwidth throttling (rate limiter) 限制服务器最大的响应 QPS = 1000 典型的面试题之一 单位：分/秒/小时 怎么支持 spike 的情况 Fix window Sliding window Token bucket 记录上一个 request 的 Timestamp 和当前可以接受的 request 数量 收到新的 request 的时候，取新的 request 的 Timestamp 比较当前 request 的 timestamp 和之前记录的那个的差，相应的给予补给 只要 request credit 数为正，否则丢弃 设置 request credit 的上限 Web Crawler and Story FeedPoliciesThe behavior of a Web crawler is the outcome of a combination of policies: a selection policy which states the pages to download, a re-visit policy which states when to check for changes to the pages, a politeness policy that states how to avoid overloading Web sites. a parallelization policy that states how to coordinate distributed web crawlers. 算法和数据结构算法: BFS, 数据结构: Queue Get web page content by URL (seed, e.g., sina.com.cn) Parse the page and get hyperlinks Deduplicate the links (do not download the same URL twice) Append new target links to a Queue Get head from the Queue. Go back to 1. Data Processing Data collection Storage of data Processing of data Data analysis Data presentation and conclusions","link":"/2021/09/11/System-Design/"},{"title":"Webpack","text":"Webpack 介绍Webpack 是一个现在的 JavaScript 应用的静态模块打包工具。 打包： 将 Webpack 中的各种资源模块进行打包合并成一个或多个包 (Bundle)； 并且在打包的过程中，还可以对资源进行处理，比如压缩图片，将 scss 转 成 css，将 ES6 语法转成 ES5 语法，将 TypeScript 转成 JavaScript 等操作； Webpack 安装 全局安装 (指定版本号 3.6.0)npm install webpack@3.6.3 -g 局部安装—-save-dev 是开发是依赖，项目打包后不需要继续使用 12cd urlnpm install webpack@3.6.0 —-save-dev Webpack 的使用Webpack 的起步文件打包： webpack entryURL outputURL 目录结构： dist：用于存放之后打包的文件src：用于存放源文件index.js：项目入口文件index.html：；浏览器打开展示的首页package.json：通过 npm init 生成的，npm 包管理的文件 Webpack 的配置webpack.config.js 及 package.json使用 npm init 进行初始化；创建 webpack.config.js 配置文件，内容如下： 123456789101112const path = require('path');module.export = { //入口：可以是字符串/数组/对象 entry: './src/index.js', //出口：通常是一个对象，里面至少包含两个重要属性，path和filename output: { path: path.resolve(_dirname, 'dist') //动态获取路径 filename: 'bundle.js', publicPath: 'dist/' }} 通过以上配置，在终端运行 webpack 即可进行打包 package.json 中定义启动：在 package.json 中的”scripts”关键字下进行配置： 123&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack&quot;} 通过以上配置，在终端运行 npm run build 即可进行打包 loader使用步骤： 通过 npm 安装需要使用的 loader； 在 webpack.config.js 中的”modules”关键字下进行配置；loader 的安装及使用 使用 Vue 的配置 使用 npm 下载 npm install vue —-save 引入 vue 并使用： 123456import Vue from 'vue';new Vue({ el: '#app', data: { message: 'Hello Vue!' }}); 重新打包，运行程序运行时若浏览器报如下错误：则需要在 webpack.config.js 中添加如下配置指定 runtime-complier 版本： 12345resolve: { alias: { 'vue$': 'vue/dist/vue.esm.js' }} 插件 (plugin)plugin 介绍： plugin 通常用于对某个现有的架构进行扩展 webpack 中的插件就是对 webpack 现有功能的各种扩展，比如打包优化，文件压缩等 loader 和 plugin 的区别： loader 主要用于转换某些类型的模块，是一个转换器 plugin 是插件，是对 webpack 本身的扩展，是一个扩展器 plugin 的使用步骤： 通过 npm 安装需要使用的 plugins 在 webpack.config.js 中的 plugins 中进行配置 添加版权的 plugin (BannerPlugin)属于 webpack 自带插件如下修改 webpack.config.js 12345678const webpack = require('webpack');module.exports = { ... plugins: [ new webpack.BannerPlugin('最终版权归...所有') ]} 打包 html 的 plugin (HtmlWebpackPlugin)作用： 可以自动生成 index.html 文件 (可以指定模板来生成) 将打包的 js 文件，自动通过 script 标签插入到 body 中 安装：npm install html-webpack-plugin —-save-dev 使用： 1234567891011const HtmlWebpackPlugin = require('HtmlWebpackPlugin');module.exports = { ... plugins: [ new HtmlWebpackPlugin({ //指定模板 template: 'index.html' }) ]} ::若 index.html 模板中 script 中的 src 路径有问题，需要删除之前自定义的 output 中的 pubilcPath 属性:: js 压缩 plugin (uglifyjs)使用： 12345678const UglifyJsPlugin = require('uglify-webpack-plugin');module.exports = { ... plugins: [ new UglifyJsPlugin() ]} 本地服务器搭建 (dev-server)webpack 提供了一个可选的本地开发服务器，这个本地服务器基于 node.js 搭建，内部使用 express 框架，可以实现我们想要的让浏览器 自动刷新显示我们修改后的结果。 dev-server 也是作为 webpack 中的一个选项 ，选项本身可以设置以下属性： conteneBase：为哪一个文件夹提供本地服务，默认是根文件夹 port：端口号，默认 8080 端口 inline：页面实时刷新 historyApiFallback：在 SP 页面中，依赖 HTML5 的 history 模式 webpack.config.文件配置如下： 1234devServer: { contentBase: './dist', inline: true} package.json 中定义启动：在 package.json 中的”scripts”关键字下进行配置： 12345&quot;scripts&quot;: { &quot;dev&quot;: &quot;webpack-dev-server&quot; //—-open会在执行后自动打开浏览器 &quot;dev&quot;: &quot;webpack-dev-server —-open&quot;} 通过以上配置，在终端运行 npm run dev 即可执行 配置文件的分离为分离生产环境和开发环境，webpack.config.js 文件可分离为以下三个文件： base.config.js prod.config.js dev.config.js 修改 package.json 中”scripts”关键字相关属性 1234&quot;scripts&quot;: { &quot;build&quot;: &quot;webpack —-config url/prob.config.js&quot;, &quot;dev&quot;: &quot;webpack-dev-server —-open —-config url/dev.config.js&quot;} 文件后缀省略1234//base.config.jsresolve: { extensions: ['.js', '.vue', '.json'];} 通过以上设置，在导入文件时，可省略文件后缀名 文件夹别名123456//base.config.jsresolve: { alias: { '@': resolve('src') }} 通过以上设置，在填写 url 时，可直接使用”@”代替 src 文件的路径","link":"/2021/07/28/Webpack/"},{"title":"Vue","text":"简介Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 Vue.js 的安装 CDN 引入 12345&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;&lt;script src=&quot;http://cdn.jsdelivr.net/nvm/vue/dist/vue.js&quot;&gt;&lt;/script&gt;&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;&lt;script src=&quot;http://cdn.jsdelivr.net/nvm/vue&quot;&gt;&lt;/script&gt; 下载和引入 npm 安装 MVVM Vue 生命周期vue 生命周期共分为四个阶段 实例创建 DOM 渲染 数据更新 销毁实例 共有八个基本钩子函数 beforeCreate — 创建前触发的行为：vue 实例的挂载元素$el 和数据对象 data 都为 undefined，还未初始化。在此阶段可以做的事情：加 loading 事件 created — 创建后触发的行为：vue 实例的数据对象 data 有了，$el 还没有在此阶段可以做的事情：解决 loading，请求 ajax 数据为 mounted 渲染做准备 beforeMount — 渲染前触发的行为：vue 实例的$el 和 data 都初始化了，但还是虚拟的 dom 节点，具体的 data.filter 还未替换在此阶段可以做的事情：。。。 mounted — 渲染后触发的行为：vue 实例挂载完成，data.filter 成功渲染在此阶段可以做的事情：配合路由钩子使用 beforeUpdate — 更新前触发的行为：data 更新时触发在此阶段可以做的事情：。。。 updated — 更新后触发的行为：data 更新时触发在此阶段可以做的事情：数据更新时，做一些处理（此处也可以用 watch 进行观测） beforeDestroy — 销毁前触发的行为：组件销毁时触发在此阶段可以做的事情：可向用户询问是否销毁 destroyed — 销毁后触发的行为：组件销毁时触发，vue 实例解除了事件监听以及和 dom 的绑定（无响应了），但 DOM 节点依旧存在在此阶段可以做的事情：组件销毁时进行提示 Vue 的基本使用123456789101112131415161718&lt;div id=&quot;app&quot;&gt;{{message}}&lt;/div&gt;&lt;script&gt; //创建实例 const app = new vue({ el: '#app', //用于挂载要管理的元素 data: { //定义数据 message: 'Hello Vue!' }, method: { //定义方法 m1: function () { //函数体 } } });&lt;/script&gt; 模板语法插值操作Mustache使用双大括号 {{data}} 进行插值操作；不仅可以直接写变量，也可以写简单的表达式 ，如： {{data1 + data2}} ； v-once指令后面不需要跟任何表达式；表示元素和组建只渲染一次，不会随着数据的改变而改变； 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; &lt;h1 v-once&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { message: 'Hello Vue!' } })&lt;/script&gt; v-html指令后面往往跟上一个 string 类型；会将 string 的 html 解析出来并进行渲染； 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;div v-html=&quot;message&quot;&gt;&lt;/div&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { message: '&lt;h1&gt;Hello Vue!&lt;/h1&gt;' } })&lt;/script&gt; v-text作用和 Mustache 相似：用于将数据显示在界面中；通常情况下，接受一个 string 类型； 12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;h1 v-text=&quot;message&quot;&gt;&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { message: 'Hello Vue!' } })&lt;/script&gt; v-pre不对 {{ }} 进行解析，直接显示； 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;{{message}}&lt;/h1&gt; &lt;h1 v-pre&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { message: 'Hello Vue!' } })&lt;/script&gt; v-cloak在 vue 解析之前，div 中有一个属性 v-cloak；解析之后，v-cloak 删除； 属性绑定 (v-bind)简写 1234&lt;!-- 完整语法 --&gt;&lt;a v-bind:href=&quot;url&quot;&gt;&lt;/a&gt;&lt;!-- 语法糖 --&gt;&lt;a :href=&quot;url&quot;&gt;&lt;/a&gt; v-bind 绑定基本属性12345678910111213&lt;div id=&quot;app&quot;&gt; &lt;img v-bind:src=&quot;imgUrl&quot;&gt;&lt;/img&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { imgUrl: 'https://...' } })&lt;/script&gt; v-bind 绑定 class123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; .active { color: red; }&lt;/style&gt;&lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;{active:&quot; isActive}&quot;&gt;Hello Vue!&lt;/div&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { isActive: true } })&lt;/script&gt;&lt;!-- 通过methods绑定 --&gt;&lt;div id=&quot;app&quot;&gt; &lt;div :class=&quot;getClass()&quot;&gt;Hello Vue!&lt;/div&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { isActive: true }, methods: { getClass: function() { return {active: this.isActive}; } } })&lt;/script&gt; v-bind 绑定 style123456789101112131415&lt;div id=&quot;app&quot;&gt; &lt;h1 :style=&quot;{font-size:'20px'}&quot;&gt;{{message}}&lt;/h1&gt; &lt;h1 :style=&quot;{font-size:fontSize}&quot;&gt;{{message}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { message: 'Hello Vue!', fontSize: 50px } })&lt;/script&gt; 事件监听 (v-on)简写 1234&lt;!-- 完整语法 --&gt;&lt;button v-on:click=&quot;method&quot;&gt;&lt;/button&gt;&lt;!-- 语法糖 --&gt;&lt;button @click=&quot;method&quot;&gt;&lt;/button&gt; v-on 参数如果方法不需要额外的参数，方法名后面不需要小括号 () 1. 在调用参数时省略了 () ，但是方法本身需要一个参数，这是 Vue 会默认将浏览器产生的event对象传入参数 2. 调用方法时，使用 $event 来手动获取浏览器的 event 对象 v-on 修饰符 .stop .prevent .{keyCode | keyAlias} .native .once 12345678910111213141516171819&lt;!-- 阻止冒泡 --&gt;&lt;button @click.stop=&quot;method&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为 --&gt;&lt;button @click.prevent=&quot;method&quot;&gt;&lt;/button&gt;&lt;!-- 阻止默认行为，没有表达式 --&gt;&lt;form @click.prevent&gt;&lt;/form&gt;&lt;!-- 串联修饰符 --&gt;&lt;button @click.stop.prevent=&quot;method&quot;&gt;&lt;/button&gt;&lt;!-- 键修饰符，键别名 --&gt;&lt;input @keyup.enter=&quot;onEnter&quot;&gt;&lt;/input&gt;&lt;!-- 键修饰符，键代码 --&gt;&lt;!-- enter键代码为13 --&gt;&lt;input @keyup.13=&quot;onEnter&quot;&gt;&lt;/input&gt;&lt;!-- 点击回调只会触发一次 --&gt;&lt;button @click.once=&quot;method&quot;&gt;&lt;/button&gt; 条件判断 (v-if, v-else-if, v-else)v-if 和 v-else 的基本使用1234&lt;div&gt; &lt;h1 v-if=&quot;isShow&quot;&gt;isShow为true时显示&lt;/h1&gt; &lt;h1 v-else&gt;isShow为false时显示&lt;/h1&gt;&lt;/div&gt; v-if 和 v-else-if 的基本使用1234567&lt;!-- 不推荐使用v-else-if，一般用computed代替 --&gt;&lt;div&gt; &lt;h1 v-if=&quot;score&gt;=90&quot;&gt;优秀&lt;/h1&gt; &lt;h1 v-else-if=&quot;score&gt;=80&quot;&gt;良好&lt;/h1&gt; &lt;h1v-else-if=&quot;score&gt;=60&quot;&gt;及格&lt;/h1&gt; &lt;h1 v-else&gt;不及格&lt;/h1&gt;&lt;/div&gt; ::为防止 vdom 重复使用组件，需要给元素添加 key 值:: v-showv-show 的基本使用123&lt;div&gt; &lt;h1 v-show=&quot;isShow&quot;&gt;isShow为true时显示&lt;/h1&gt;&lt;/div v-if 和 v-show 的区别v-if：当条件为 false 时，包含 v-if 指令的元素，根本不会存在于 dom 中；v-show：当条件为 false 时，v-show 只是将元素的 display 属性设置为 none； 循环遍历 (v-for)v-for 遍历数组12345678910111213141516171819&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item&quot; in arr&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;!-- 同时获取下标 --&gt; &lt;ul&gt; &lt;li v-for=&quot;(item,index)&quot; in arr&quot;&gt;{{index}}. {{item}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { arr: ['a1','a2','a3'] } })&lt;/script&gt; v-for 遍历对象1234567891011121314151617181920212223242526272829&lt;div&gt; &lt;!-- 获取的是value --&gt; &lt;ul&gt; &lt;li v-for=&quot;item&quot; in info&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;!-- 获取的是key和value --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,key)&quot; in info&quot;&gt;{{key}}: {{value}}&lt;/li&gt; &lt;/ul&gt; &lt;!-- 获取的是key、value、index --&gt; &lt;ul&gt; &lt;li v-for=&quot;(value,key,index)&quot; in info&quot;&gt;{{index}}. {{key}}: {{value}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { info: { name: 'Shihao', age: 21, height: 1.70 } } })&lt;/script&gt; v-for 绑定 key1234&lt;!-- 绑定的key需要和item对应且唯一 --&gt;&lt;ul&gt; &lt;li v-for=&quot;item&quot; in arr&quot; :key=&quot;item&quot;&gt;{{item}}&lt;/li&gt;&lt;/ul&gt; ::不建议 key 绑定 index:: 数组中的响应式方法 .push() - 在最后添加一个或多个元素 .pop() - 删除最后一个元素 .shift() - 删除第一个元素 .unshift() - 在最前面添加一个或多个元素 .splice() - 删除/插入/替换某一位置的元素 .splice(index, howmany, …element ) 删除：第二个参数传入删除几个元素 替换：第二个元素传图替换几个元素 插入：第二个参数传入0，第三个参数传入要插入的元素 .sort() - 排序 .reverse() - 数组反转 .$set() - vue 内部提供 .$set(要修改的对象,index,修改后的值)通过索引直接改变元素不是响应式 表单绑定 (v-model)v-model 实现表单元素和数据的双向绑定； v-model 的基本使用123456789101112&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;text&quot; v-model=&quot;message&quot; /&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { message: 'Hello Vue!' } });&lt;/script&gt; v-model 原理v-model 实质上包含两个操作： 1. v-bind 绑定一个 value 属性； 2. v-on 指令给当前元素绑定 input 事件；&lt;input type=&quot;text&quot; v-model=&quot;message&quot; &gt;等同于&lt;input type=&quot;text&quot; :value=&quot;message&quot; @input=&quot;message=$event.target.value&quot;&gt; v-model 结合 radio (单选框)123456789101112&lt;div id=&quot;app&quot;&gt; &lt;label for=&quot;male&quot;&gt; &lt;input type=&quot;radio&quot; v-model=&quot;sex&quot; id=&quot;male&quot; name=&quot;sex&quot; value=&quot;男&quot; /&gt;男 &lt;/label&gt; &lt;label for=&quot;female&quot;&gt; &lt;input type=&quot;radio&quot; v-model=&quot;sex&quot; id=&quot;female&quot; name=&quot;sex&quot; value=&quot;女&quot; /&gt;女 &lt;/label&gt; &lt;h2&gt;选择的性别：{{sex}}&lt;/h2&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { sex: '' } });&lt;/script&gt; v-model 结合 checkbox 单选框 1234567891011&lt;div id=&quot;app&quot;&gt; &lt;label for=&quot;agree&quot;&gt; &lt;input type=&quot;checkbox&quot; id=&quot;agree&quot; v-model=&quot;isAgree&quot; /&gt;同意 &lt;/label&gt; &lt;button :disable=&quot;!isAgree&quot;&gt;下一步&lt;/button&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { isAgree: false //布尔类型 } })&lt;/script&gt; 多选框 123456789101112&lt;div id=&quot;app&quot;&gt; &lt;input type=&quot;checkbox&quot; value=&quot;篮球&quot; v-model=&quot;hobbies&quot; /&gt;篮球 &lt;input type=&quot;checkbox&quot; value=&quot;足球&quot; v-model=&quot;hobbies&quot; /&gt;足球 &lt;input type=&quot;checkbox&quot; value=&quot;羽毛球&quot; v-model=&quot;hobbies&quot; /&gt;羽毛球&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { hobbies: [] //数组类型 } })&lt;/script&gt; v-model 结合 select 单选 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;select name=&quot;sel&quot; v-model=&quot;fruits&quot;&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;&quot;&gt;草莓&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { fruits: '苹果' //字符串类型 } })&lt;/script&gt; 多选 1234567891011121314&lt;div id=&quot;app&quot;&gt; &lt;select name=&quot;sel&quot; v-model=&quot;fruits&quot; multiple&gt; &lt;option value=&quot;苹果&quot;&gt;苹果&lt;/option&gt; &lt;option value=&quot;香蕉&quot;&gt;香蕉&lt;/option&gt; &lt;option value=&quot;草莓&quot;&gt;草莓&lt;/option&gt; &lt;/select&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { fruits: [] //数组类型 } })&lt;/script&gt; 值绑定123456789101112131415&lt;div&gt; &lt;label v-for=&quot;item in originHobbies&quot; :for=&quot;item&quot;&gt; &lt;input type=&quot;checkbox&quot; :value=&quot;item&quot; :id=&quot;item&quot; v-model=&quot;hobbies&quot;&gt;{{item}}&lt;/input&gt; &lt;/label&gt;&lt;/div&gt;&lt;script&gt; const app = new vue({ el: '#app', data: { hobbies: [], originHobbies: ['篮球', '足球', '羽毛球'] } })&lt;/script&gt; v-model 修饰符 .lazy .number .trim 123456789&lt;!-- 用户敲下回车或失去焦点时再绑定 --&gt;&lt;input type=&quot;text&quot; v-model.lazy=&quot;message&quot; /&gt;&lt;!-- v-model默认绑定string类型 --&gt;&lt;!-- 转换为number类型 --&gt;&lt;input type=&quot;number&quot; v-model.number=&quot;age&quot; /&gt;&lt;!-- 去掉字符串左右两边的空格 --&gt;&lt;input type=&quot;text&quot; v-model.trim=&quot;message&quot; /&gt; 计算属性 (computed)12345678910111213141516171819202122232425&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;{{fullName}}&lt;/h1&gt; &lt;h1&gt;{{getFullName()}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { firstName: 'Shihao', lastName: 'Xiong' }, computed: { fullName: function() { return this.firstName + ' ' + this.lastName; } }, methods: { getFullName: function() { return this.firstName + ' ' + this.lastName; } } })&lt;/script&gt; methods 和 computed可以使用 methods 来替代 computed，效果上两个都是一样的，但是 computed 是基于它的依赖缓存，只有相关依赖发生改变时才会重新取值。而使用 methods ，在重新渲染的时候，函数总会重新调用执行。::使用 computed 性能会更好，但是如果不希望缓存，可以使用 methods 属性:: 计算属性的 setter 和 getter123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;h1&gt;{{fullName}}&lt;/h1&gt;&lt;/div&gt;&lt;script&gt; //创建实例 const = app new vue({ el: '#app', data: { firstName: 'Shihao', lastName: 'Xiong' }, computed: { //计算属性一般没有set方法 // fullName: { // set: function(newValue) {}, // get: function() { // return this.firstName + ' ' + this.lastName; // } // } //以下为以上方式的简写 fullName() { return this.firstName + ' ' + this.lastName; } } })&lt;/script&gt; 过滤器 (filters)1234567891011121314151617181920&lt;div id=&quot;app&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item&quot; in price&quot;&gt;{{item | showPrice}}&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;script&gt; const app = new Vue({ el: '#app', data: { price: [85, 123, 48, 34] } filters: { showPrice(price) { //.toFixed(x) - 保留x位小数 return '¥' + price.toFixed(2); } } })&lt;/script&gt; 组件化开发注册组件的基本步骤 创建组件构造器 调用 Vue.extend() 创建的是一个组件构造器 通常在创建组件构造器时，传入 template 代表自定义组件的模板 通常，Vue2.x 可使用简写方式 1234//基本创建方法const cpnConstructor = Vue.extend({ template: `...`}); 注册组件 调用 Vue.component() 将创建的组件构造器注册为一个组件，并赋予其标签名 需要传递两个参数： 注册组件的标签名 组件构造器 12//全局组件Vue.component('my-cpn', cpnConstructor); 使用组件 1&lt;my-cpn&gt;&lt;/my-cpn&gt; 全局组件和局部组件全局组件：可以在多个 Vue 实例中使用局部组件：在 Vue 实例中注册 12345678//局部组件注册const app = new Vue({ el: '#app', data: {...}, components: { 'my-cpn': cpnConstructor }}) 父组件和子组件123456789101112131415161718192021222324252627&lt;div id=&quot;app&quot;&gt; &lt;cpn2&gt;&lt;/cpn2&gt;&lt;/div&gt;&lt;script&gt; //cpn1为子组件，cpn2为父组件 const cpn1 = Vue.extend({ template: `...` }) const cpn2 = Vue.extend({ template: ` ... &lt;cpn1&gt;&lt;/cpn1&gt;`, components: { //允许在cpn2的template中使用cpn1组件 'cpn1': cpn1 } }) const app = new Vue({ el: '#app', data: {...}, components: { 'cpn2': cpn2 } })&lt;/script&gt; 注册组件的简写方式省去 extend，直接使用对象代替 123456789101112131415161718//不再需要Vue.extend()//直接注册//全局组件Vue.component('my-cpn', { template: `...`})//局部组件const app = new Vue({ el: '#app', data: {...}, components: { 'my-cpn': { template: `...` }) }}) 组件模板抽离方法两种定义模板的方法： 1. script 标签，type 设为 text/x-template 2. template 标签 123456789101112131415161718192021222324252627&lt;!-- 定义模板-script标签：类型为text/x-template --&gt;&lt;script type=&quot;text/x-template&quot; id=&quot;cpn&quot;&gt; //html代码&lt;/script&gt;&lt;!-- 定义模板-template标签 --&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;!-- html代码 --&gt;&lt;/template&gt;&lt;script&gt; //全局组件 Vue.component('my-cpn', { template: '#cpn' }) //局部组件 const app = new Vue({ el: '#app', data: {...}, components: { 'my-cpn': { template: '#cpn' } } })&lt;/script&gt; 组件数据的存放 组件对象使用 data 属性存放数据 data 属性必须是一个函数 函数返回一个对象，对象内部保存数据 123456789101112131415161718192021&lt;div id=&quot;app&quot;&gt; &lt;my-cpn&gt;&lt;/my-cpn&gt;&lt;/div&gt;&lt;template id=&quot;myCpn&quot;&gt; &lt;div&gt;{{message}}&lt;/div&gt;&lt;/template&gt;&lt;script&gt; const app = new Vue({ el: '#app', components: { cpn: { template: '#myCpn', data() { return { message: 'Hello Vue!' }; } } } });&lt;/script&gt; 父子组件通信 通过 props 向子组件传递数据 通过事件向父组件发送信息 父传子 (props)props 基本用法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;div id=&quot;app&quot;&gt; &lt;cpn :cmovies=&quot;movies&quot; :cmessage=&quot;message&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;p&gt;{{cmovies}}&lt;/p&gt; &lt;h2&gt;{{cmessage}}&lt;/h2&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const cpn = { template: '#cpn', //1. 传入数组 props: ['cmovies', 'cmessage'], //2. 传入对象 props: { //1. 类型限制 cmovies: Array, cmessage: String, //2. 提供一些默认值 cmessage: { type: String, default: '...', //设置必传属性，表示cmessage不可缺失 required: true } cmovies: { type: Array, //类型是对象或者数组时，默认值必须是一个函数 default() { return [] } } } data() { return {} } } const app = new Vue({ el: '#app', data: { movies: ['m1','m2','m3'], message: 'Hello Vue!' }, components: { cpn } })&lt;/script&gt; props 数据验证props 可传入数组或对象，当需要对props 进行类型验证时，需要传入对象。验证支持的类型_ string_ number_ boolean_ array_ object_ date_ function_ symbol 1234567891011121314151617181920212223242526272829303132333435363738Vue.component('my-cpn', { props: { //基础的类型检查 ('null'匹配任何类型) propA: number, //多个可能的类型 propB: [String, Number], //必填的字符串 propC: { type: String, required: true }, //带有默认值的数字 prosD: { type: Number, default: 100 }, //带有默认值的对象 propE: { type: Object, //对象或数组默认值必须是一个工厂函数获取 default() { return { message: 'hello' }; } }, //自定义验证函数 propF: { validator(value) { //这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1; } } }}); 子传父 (自定义事件)自定义事件流程： 1. 在子组件中，通过 $emit() 来触发事件 2. 在父组件中，通过 v-on 来监听子组件事件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;div id=&quot;app&quot;&gt; &lt;cpn @itemclick=&quot;cpnClick&quot;&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;button v-for:&quot;item in categories&quot; @click=&quot;btnClick(item)&quot;&gt;{{item.name}}&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //子组件 const cpn = { template: '#cpn', data() { return { categories: [ { id: 'aaa', name: '推荐' }, { id: 'bbb', name: '手机' }, { id: 'ccc', name: '电器' }, ] } }, methods: { btnClick(item) { //发射事件，自定义事件 this.$emit('itemclick', item); } } } //父组件 const app = new Vue({ el: '#app', data: { movies: ['m1','m2','m3'], message: 'Hello Vue!' }, components: { cpn }, methods: { cpnClick(item) { //console.log(item); } } })&lt;/script&gt; 父访问子 ($children/$refs) 父组件访问子组件使用 $children 或者 $refs this.$children 是一个数组类型，它包含所有子组件对象 this.$refs 是一个对象类型，默认是空对象 12345678910111213141516171819202122232425262728293031323334353637&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;cpn ref=&quot;myCpn&quot;&gt;&lt;/cpn&gt; &lt;button @click=&quot;btnClick&quot;&gt;&lt;/button&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;!-- 模板代码 --&gt;&lt;/template&gt;&lt;script&gt; //子组件 const cpn = { template: '#cpn' }; //父组件 const app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, components: { cpn }, methods: { btnClick() { //$children访问子组件 this.$children[0].data; //$refs访问子组件，需要在子组件上添加ref属性 this.$refs.myCpn.data; } } });&lt;/script&gt; 子访问父 ($parent)1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;ccpn&gt;&lt;/ccpn&gt; &lt;/div&gt;&lt;/template&gt;&lt;template id=&quot;ccpn&quot;&gt; &lt;div&gt; &lt;!-- 模板代码 --&gt; &lt;button @click=&quot;btnClick&quot;&gt;&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; //子组件 const ccpn = { template: '#ccpn', methods: { btnClick() { //$parent访问父组件 this.$parent.data //$root访问跟组件 this.$root } } } const cpn = { template: '#cpn', data: { return { ... } }, components: { ccpn } } //父组件 const app = new Vue({ el: '#app', data: { message: 'Hello Vue!' }, components: { cpn } })&lt;/script&gt; 插槽 (slot)组件的插槽：为了让封装的组件更加具有扩展性，让使用者决定组件内部的一些内容到底展示什么 slot 的基本使用1234567891011121314151617181920212223242526272829303132333435363738&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt; &lt;!-- button会替换到slot的位置 --&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/cpn&gt; &lt;cpn&gt; &lt;!-- 多个元素会全部替换 --&gt; &lt;h1&gt;title&lt;/h1&gt; &lt;button&gt;按钮&lt;/button&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;!-- 模板代码 --&gt; &lt;!-- 插槽：预留元素位置 --&gt; &lt;slot&gt;&lt;/slot&gt; &lt;!-- 带默认的slot --&gt; &lt;slot&gt;&lt;button&gt;按钮&lt;/button&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const cpn = { template: '#cpn', } const app = new Vue({ el: '#app', data: { ... }, components: { cpn } })&lt;/script&gt; 具名插槽的使用12345678910111213141516171819202122232425262728293031&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt; &lt;!-- 替换center插槽 --&gt; &lt;button v-slot=&quot;center&quot;&gt;&lt;/button&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;!-- ...模板代码... --&gt; &lt;slot name=&quot;left&quot;&gt;&lt;span&gt;左边&lt;/span&gt;&lt;/slot&gt; &lt;!-- ...模板代码... --&gt; &lt;slot name=&quot;center&quot;&gt;&lt;span&gt;中间&lt;/span&gt;&lt;/slot&gt; &lt;!-- ...模板代码... --&gt; &lt;slot name=&quot;right&quot;&gt;&lt;span&gt;右边&lt;/span&gt;&lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const cpn = { template: '#cpn', } const app = new Vue({ el: '#app', data: { ... }, components: { cpn } })&lt;/script&gt; 编译作用域::父级模板里的所有内容都是在父级作用域中编译的；子模板里的所有内容都是在子作用域中编译的:: 作用域插槽父组件替换插槽的标签，但是内容由子组件来提供 123456789101112131415161718192021222324252627282930313233343536373839&lt;div id=&quot;app&quot;&gt; &lt;cpn&gt;&lt;/cpn&gt; &lt;!-- 获取子组件中的pLanguages --&gt; &lt;cpn&gt; &lt;template v-slot:default=&quot;{pLanguages}&quot;&gt; &lt;span v-for=&quot;item&quot; in slotProps.data&quot;&gt;&lt;/span&gt; &lt;/template&gt; &lt;/cpn&gt;&lt;/div&gt;&lt;template id=&quot;cpn&quot;&gt; &lt;div&gt; &lt;slot :pLanguages=&quot;pLanguages&quot;&gt; &lt;ul&gt; &lt;li v-for=&quot;item&quot; in pLanguages&quot;&gt;{{item}}&lt;/li&gt; &lt;/ul&gt; &lt;/slot&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; const cpn = { template: '#cpn', data() { return { pLanguages: ['javascript','C++','Swift'] } } } const app = new Vue({ el: '#app', data: { ... }, components: { cpn } })&lt;/script&gt; 模块化开发模块化的两个核心：导入和导出 CommonJS CommonJS 的导出 123456module.exports = { flag: true, demo(a, b) { return a + b; }}; CommonJS 的导入 1234567//CommonJS模块let { flag, demo } = require('url');//等同于let _mA = require('url');let flag = _mA.flag;let demo = _mA.demo; ES6 的模块化 html 引入&lt;script src=&quot;url&quot; type=&quot;module&quot;&gt;&lt;/script&gt; export (导出)export 用于导出变量/函数/类 1234567891011//info.jslet name = 'Shihao';let age = 21;function func() { //函数体}class Person { //内容}export { name, age, func, Person }; * **export default** 123456789let address = &quot;Sichuan&quot;;//export default只允许导出一个参数export default name//导出函数export default function() { //函数体} import (导入) 12345678910//导入参数可选import { name, Person } from './info.js';//统一全部导入，param为自命名参数import * as param from './info.js';//使用导出的类let p = new Person();//使用export default的导入，可自命名参数，不需要{}import myParam from './info.js'; WebpackWebpack el 和 template 的区别问题： 1. 如果我们希望将 data 中的数据显示在界面中，就必须修改 index.html 2. 如果我们后面自定义了组件，也必须修改 index.html 来使用组件 3. 但是 html 模板在之后的开发中，我们并不希望手动的来频繁修改，是否可以做到？ 解决方案：定义 template 属性： 1. 在前面的 Vue 实例中，我们定义了 el 属性，用于 index.html 和#app 进行绑定，让 Vue 实例之后可以管理它其中 的内容 2. 这里，我们可以将 div 元素中的内容删掉，只保留一个基本的 id 为 div 的元素但是如果我们依然希望在其中显示的内容，我们可以再定义一个 template 属性： 1234567new Vue({ el: '#app', template: ` &lt;div id=&quot;app&quot;&gt;{{message}}&lt;/div&gt; `, data: { message: '...' }}); ::以上代码在运行时，Vue 会将 index.html 中 id 为 app 的 div 替换为 template 中的代码:: 代码简化：当 template 中代码过多时，为简化 Vue 实例中的代码，将 template 中的代码抽离出来创建为组件使用： 1234567891011121314151617181920&lt;!-- App.vue --&gt;&lt;!-- Vue文件，用于定义组件 --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt;{{message}}&lt;/div&gt;&lt;template&gt;&lt;script&gt; export default { name: &quot;App&quot;, data() { return { message: '...' } } }&lt;/script&gt;&lt;!-- 设置css样式 --&gt;&lt;style scoped&gt;&lt;style&gt; 123456789import App from './app.vue';new Vue({ el: '#app', template: '&lt;App&gt;&lt;/App&gt;', components: { App }}); vue 文件封装处理： 安装 vue-loader 和 vue-template-compiler 修改 webpack.config.js 配置 1234{ tese:: /\\.vue$/, use: ['vue-loader']} Vue CLICLI (Command-Line Interface)，翻译为命令行界面，俗称脚手架。Vue CLI 是一个官方发布的 vue.js 项目脚手架，使用 vue-cli 可以快速搭建 Vue 开发环境以及对应的 webpack 配置。 安装：Vue CLI 3npm install -g @vue/cliVue CLI 3 初始化项目vue create 项目名称 拉取 2.x 模板 (旧版本)npm install -g @vue/cli-initVue CLI 2 初始化项目vue init webpack 项目名称 runtime-compiler 和 runtime-only区别： runtime-compilertemplate → ast → render → vdom → UI runtime-onlyrender → vdom → UI 1234567891011121314151617const cpn = { template: '&lt;div&gt;{{message}}&lt;/div&gt;', data() { return { message: 'hello vue' } }}new Vue({ el: '#app', render: function(createElement) { //1. 普通用法：createElement('标签', {标签的属性}, ['']) return createElement('h2', {class: 'box'}, ['hello world'], createElement('button', ['按钮'])]); //2. 传入组件对象 return createElement(cpn); }}) Vue CLI 3特点： vue cli 是基于 webpack 3 开发 移除配置文件根目录下的 build 和 config 等目录 提供了 vue ui 命令，提供了可视化配置 移除了 static 文件夹，新增了 public 文件夹，并且 index.html 移动到 public 中 目录结构： 路由和映射 路由：路由 (routing)就是通过互联的网络吧信息从源地址传输到目的地址的活动。 映射表：决定了数据包的指向。 URL 的 hash 和 HTML5 的 historyurl 的 hash： url 的 hash 也就是锚点，本质上是改变 window.location 的 href 属性 可以直接通过 location.hash 来改变 href，到那时页面不发生刷新 HTML5 的 history： pushState：相当于入栈和出栈，可返回 replaceState：不可返回 go vue-routervue-router 是基于路由和组件的 路由用于设定访问路径，将路径和组件映射起来 在 vue-router 的单页面应用中，页面的路径的改变就是组件的切换 安装：npm install vue-router —-save 配置： 导入路由对象，并调用 Vue.use(VueRouter) 创建路由实例，并传入路由映射配置 在 Vue 实例中挂载创建的路由实例 123456789101112131415161718192021222324//router/index.js//导入路由import Vue from 'vue';import Router from 'vue-router';import home from '../components/home.vue';import about from '../components/about.vue';//通过Vue.use(插件)，安装插件Vue.use(Router);//创建Router对象export default new Router({ routes: [ { path: '/home', component: home }, { path: '/about', component: about } ]}); 使用： 创建路由组件 配置路由映射：组件和路径映射关系 使用路由，通过 &lt;router-link&gt; 和 &lt;router-view&gt; 12345678&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link to=&quot;/home&quot;&gt;首页&lt;/router-link&gt; &lt;router-link to=&quot;/about&quot;&gt;关于&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 路由的默认值和修改为 history1234567891011121314151617181920export default new Router({ routes: [ { //设置路由默认值 path: '', redirect: '/home' }, { path: '/home', component: home }, { path: '/about', component: about } ], //设置为history mode: 'history'}); router-link属性： to：用于指定跳转的路径 tag：指定 &lt;router-link&gt; 之后渲染什么组件&lt;router-link to='...' tag='button'&gt;&lt;/router-link&gt;以上渲染出 button replace：replace 不会留下 history 记录，指定 replace 的情况下，后退键不能返回上一个页面 active-class：当 &lt;router-link&gt; 对应的路由匹配成功时，会自动给当前元素设置一个 router-link-active 的 class设置 active-class 可以修改默认名称_ 在进行高亮显示的导航菜单或底部 tabbar 时，会使用到该类_ 但是通常不会修改类的属性，会直接使用默认的 router-link-active 通过代码跳转路由123456789101112131415161718192021&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;'homeClick'&quot;&gt;首页&lt;/button&gt; &lt;button @click=&quot;'aboutClick'&quot;&gt;关于&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App', methods: { homeClick() { this.$router.push('/home') } aboutClick() { this.$router.push('/about') } } }&lt;/script&gt; 动态路由123456789101112131415161718&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;router-link :to=&quot;'/user/'+ userID&quot;&gt;用户&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App', data() { return { userID: 'shihao' }; } };&lt;/script&gt; 12345678910//router/index.jsexport default new Router({ routes: [ { path: '/user/:userID', component: user } ], mode: 'history'}); 12345678910111213141516171819&lt;!-- user.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;用户&lt;/h2&gt; &lt;p&gt;{{userID}}&lt;/p&gt; &lt;p&gt;{{$route.params.userID}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'user', computed: { userID() { return this.$route.params.userID; } } };&lt;/script&gt; 路由的懒加载当打包构建应用时，JavaScript 包会变得非常大，影响页面加载。将不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，就会更加高效。 路由的懒加载主要作用是将路由对应的组件打包成一个个的 js 代码块，只有在这个路由被访问到的时候才加载对应的组件。 路由懒加载的效果 懒加载的方式 结合 Vue 的异步组件和 Webpack 代码分析 12345const home = resolve =&gt; { require.ensure(['../components/home.vue'], () =&gt; { resolve(require('../components/home.vue')); });}; AMD 写法 1const about = resolve =&gt; require(['../components/about.vue'], resolve); ES6 1const home = () =&gt; import('../components/home.vue'); 路由的嵌套路径和组件的关系 实现的步骤： 创建对应的子组件，并且在路由映射中配置对应的子路由 在组件内部使用 &lt;router-view&gt; 标签 12345678910111213141516171819202122232425//router/index.jsconst homeNews = () =&gt; import('../components/homeNews.vue');const homeMessage = () =&gt; import('../components/homeMessage.vue');routes: [ { path: '/home', component: home, children: [ //默认子路由 { path: '', redirect: 'news' }, { //子路由path不需要&quot;/&quot; path: 'news', component: homeNews }, { path: 'message', component: homeMessage } ] }]; 12345678910&lt;!-- home.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;首页&lt;/h2&gt; &lt;router-link to=&quot;/home/news&quot;&gt;新闻&lt;/router-link&gt; &lt;router-link to=&quot;/home/message&quot;&gt;消息&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 参数传递 params 类型_ 配置路由格式：/router/:id_ 传递的方式：在 path 后面跟上对应的值 * 传递后形成的路径：/router/123动态路由 query 类型 配置路由格式：/router 传递的方式：对象中使用 query 的 key 作为传递方式 传递后形成的路径：/router?id=123 123456789&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;!-- &lt;router-link to=&quot;/profile&quot;&gt;我的&lt;/router-link&gt; --&gt; &lt;router-link :to=&quot;{path: '/profile', query: {name: 'xsh'}}&quot;&gt;Profile&lt;/router-link&gt; &lt;router-view&gt;&lt;/router-view&gt; &lt;/div&gt;&lt;/template&gt; 1234567&lt;!-- profile.vue --&gt;&lt;template&gt; &lt;div&gt; &lt;h2&gt;Profile&lt;/h2&gt; &lt;p&gt;{{$route.query.name}}&lt;/p&gt; &lt;/div&gt;&lt;/template&gt; 通过代码传递 123456789101112131415161718192021222324252627&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div id=&quot;app&quot;&gt; &lt;button @click=&quot;'userClick'&quot;&gt;用户&lt;/button&gt; &lt;button @click=&quot;'ProfileClick'&quot;&gt;Profile&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { name: 'App', methods: { homeClick() { this.$router.push('/user/' + this.userID) } profileClick() { this.$router.push({ path: '/profile', query: { name: 'xsh', age: 21 } }) } } }&lt;/script&gt; $router和$route $router为VueRouter实例，想要导航到不同的URL，使用 $router.push 方法 $route 为当前 router 跳转对象，里面可以获取 name、path、queryparams 等 导航守卫监听页面的跳转 12345678910111213141516171819202122232425262728293031323334353637//router/index.js//根据不同的页面修改页面titleconst routes = [ { //设置路由默认值 path: '', redirect: '/home' }, { path: '/home', component: home, meta: { title: '首页' } }, { path: '/about', meta: { title: '关于' }, component: about }];const router = new Router({ routes, mode: 'history'});//router.beforeEach((to, from, next) =&gt; { //从from跳转到to document.title = to.matched[0].meta.title; next();});export default router; ::前置钩子 (beforeEach)需要主动调用 next()函数，后置钩子 (afterEach) 不需要主动调用 next()函数::以上为全局导航守卫，除此之外还有路由独享守卫和组件内守卫 keep-alivekeep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。 router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存。 activated() 和 deactivated() 两个函数只有在该组件使用了 keep-alive 时才有效 属性 include — 字符串或正则表达式，只有匹配的组件会被缓存 exclude — 字符串或正则表达式，任何匹配的组件都不会被缓存 123&lt;keep-alive exclude=&quot;home,user&quot;&gt; &lt;router-view&gt;&lt;/router-view&gt;&lt;/keep-alive&gt; VuexVuex 是一个专门为 Vue.js 应用程序开发的状态管理模式 采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化 Vuex 也集成到 Vue 官方调试工具devtools extension，提供了诸如零配置的 time-travel 调试，状态快照导入导出等高级调试 状态管理：可理解为把需要多个组件共享的变量全部储存在一个对象里面，然后将这个对象放在顶层 Vue 实例中，让其他组件可以使用。 单页面状态管理 State：状态，可理解为 data 中的属性 View：视图层，可以针对 State 的变化显示不同的信息 Actions：用户的各种操作，如点击、输入等，会导致状态等改变 多界面状态管理Vuex 的基本使用 12345678910111213141516171819202122232425//store/index.jsimport Vue from 'vue';import Vuex from 'vuex';//安装插件Vue.use(Vuex);//创建对象const store = new Vuex.Store({ state: { //定义数据 data: 0 }, //定义方法 mutations: {}, //执行异步代码 actions: {}, //类似于计算属性 getters: {}, //模块 modules: {}});//导出store对象export default store; Views 调用 {{$store.state.data}} ::异步操作需要在 Actions 中完成:: vuex-devtools 和 mutations vuex-devtools浏览器插件，跟踪 state 的改变 mutations 123456789//store/index.jsconst store = new Vuex.Store({ //定义方法 mutations: { func() { //... } }}); 12345678910111213141516&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div @click=&quot;click&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { //... methods: { click() { //通过commit调用mutations中的func方法 this.$store.commit('func'); } } };&lt;/script&gt; Vuex 核心概念 State Getters Mutations Actions Modules State 单一状态树单一状态树 (Singly Source of Truth)，也称单一数据源 Vuex 推荐将所有状态信息保存在一个 store 中，以方便管理和维护 Getters类似于单个组件中的计算属性 Getters 的基本使用123456789//store/index.jsconst store = new Vuex.Store({ state: { counter: 5 }, getters: { powerCounter(state) { return state.counter * state.counter; } }}); 1234&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt;{{$store.getters.powerCounter}}&lt;/div&gt;&lt;/template&gt; Getters 作为参数和传递参数 作为参数 12345678910111213//store/index.jsconst store = new Vuex.Store({ state: { counter: 5 }, getters: { func1(state) { //... }, func2(state, getters) { //使用func1 //getters.func1 } }}); 传递参数 123456789101112131415//store/index.jsconst store = new Vuex.Store({ state: { counter: 5 }, getters: { func1(state) { //... }, func2(state) { //使用返回的函数接收View传入的参数 return function (param) { return; //... }; } }}); 1234&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div&gt;{{$store.getters.func2(...)}}&lt;/div&gt;&lt;/template&gt; MutationsVuex 的 store 状态更新的唯一方式：提交 Mutation Mutation 主要包括两部分： 字符串的事件类型 (type) 一个回调函数 (handler)，该回调函数的第一个参数就是 stateMutations 的使用 Mutations 传递参数参数被称为是 mutation 的负载 (payload) 12345678910//store/index.jsconst store = new Vuex.Store({ //定义方法 mutations: { //通过第二个参数传入 func(state, param) { //... } }}); 12345678910111213141516&lt;!-- App.vue --&gt;&lt;template&gt; &lt;div @click=&quot;click(...)&quot;&gt;&lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { //... methods: { click(param) { //通过commit调用mutations中的func方法 this.$store.commit('func', param); } } };&lt;/script&gt; Mutations 提交风格除了上面通过 commit() 进行提交，Vue 还提供了另外一种风格，它是一个包含 type 属性的对象 12345678910111213&lt;script&gt; export default { //... methods: { click(param) { this.$store.commit({ type: 'funcName', data }); } } };&lt;/script&gt; 123456789//store/index.jsconst store = new Vuex.Store({ mutations: { func(state, payload) { //... //payload为整个commit中的对象 } }}); Mutations 响应规则Vuex 的 store 中的 state 是响应式的，当 state 中的数据发生改变时，Vue 组件会自动更新 这就要求我们必须遵守一些 Vuex 对应的规则： 提前在 store 中初始化好所需要的属性 当给 state 中的对象添加/删除新属性时，使用以下方法： 使用 Vue.set(obj, 'newProp', param) 添加属性；Vue.delete(obj, 'prop') 删除属性 用新对象给旧对象重新赋值 Mutations 类型常量123//store/mutations-types//定义类型常量export const FUNC = 'func'; 类型常量的使用： 12345678910//store/index.jsimport * from './store/mutations-types'const store = new Vuex.Store({ mutations: { [FUNC](state, payload) { //... } }}); 12345678910&lt;script&gt; export default { //... methods: { click() { this.$store.commit(FUNC); } } };&lt;/script&gt; Mutations 同步函数通常情况下，Vuex 要求 Mutations 中的方法必须是同步方法，主要原因是当使用 devtools 时，可以帮助我们捕捉 Mutations 的快照。 ActionsActions 类似于 Mutations，但是是用来替代 Mutations 执行异步操作 Actions 的基本使用12345678910111213141516171819//store/index.jsimport * from './store/mutations-types';const store = new Vuex.Store({ mutations: { funcM(state) { //更改state中的属性 } }, actions: { //context可理解为store对象 funcA(context, payload) { //仿异步操作更改state中的属性 setTimeout({ context.commit('funcM'); }, 1000) } }}); 12345678910&lt;script&gt; export default { //... methods: { click() { this.$store.dispatch('funcA', param); } } };&lt;/script&gt; 结合 Promise12345678910111213141516//store/index.jsimport * from './store/mutations-types'const store = new Vuex.Store({ actions: { //context可理解为store对象 funcA(context, payload) { return new Promise((resolve) =&gt; { setTimeout({ //... resolve() }, 1000) }) } }}); 123456789101112&lt;script&gt; export default { //... methods: { click() { this.$store.dispatch('funcA', param).then(() =&gt; { //... }); } } };&lt;/script&gt; context 对象的解构通过 {} 对 context 进行解构，取出需要的属性::属性通过名字对应:: 12345678//store/index.jsconst store = new Vuex.Store({ actions: { funcA({ state, commit }) { //... } }}); ModulesVue 使用单一状态树，意味着很多状态都会交给 Vuex 来管理。当应用变得非常复杂时，store 对象就有可能变得相当臃肿，为了解决这个问题，Vuex 允许我们将 store 分割成模块，而每个模块 拥有自己的 state、mutations、actions、getters 等。 1234567const store = new Vuex.Store({ modules: { moduleA: {}, moduleB: {} //... }}); 获取模块 state &lt;div&gt;{{$store.state.moduleA}}&lt;/div&gt; Mutations 和 Getters 用法和以上一样，命名保持不一样 模块中 Getters 通过第三个参数访问 store 中的 state comProp(state, payload rootState) {} 模块中 Actions 的 context 可理解为可访问 store 的本模块对象 项目结构推荐将mutations、actions、getters、modules抽离作为模块导入 index.js，modules 每个模块推荐形成单一文件。 网络模块封装 (axios)功能特点 在浏览器中发送 XMLHttpRequests 请求 在 node.js 中发送 http 请求 支持 Promise API 拦截请求和响应 转换请求和响应数据 … axios 请求方式支持多种请求方式： axios(config) axios.request(config) axios.get(url[, config]) axios.delete(url[, config]) axios.head(url[, config]) axios.post(url[, data[, config]]) axios.put(url[, data[, config]]) axios.patch(url[, data[, config]]) axios 的基本使用安装npm install axios —-save 使用 1234567891011121314import axios from 'axios';//支持Promise，内置resolve，可直接调用.then()axios({ //httpbin.org可用于网络模拟 //123.207.32.32:8000/home/multidata可用于相关测试 //123.207.32.32:8000/home/data?...可用于相关测试 (含参数) url: 'httpbin.org', method: 'get', //针对get请求的参数拼接 params: {}}).then(res =&gt; { //...}); 发送并发请求 使用 axios.all([]) 发送并发请求 axios.all([]) 返回的结果是一个数组，使用 axios.spread 可讲数组[res1, res2]展开为 res1，res2 1axios.all([axios({...}),axios({...})]).then(axios.spread((res1, res2) =&gt; {...})) 全局配置BaseURLaxios.defaults.baseURL = '...';axios.defaults.headers.post['Content-Type'] = 'application/x-www-form-urlencoded'; 常见的配置选项 请求地址：url: ‘/user’ 请求类型：method: ‘get’ 请根路径：baseURL: ‘http://…’ 请求前的数据处理：transformRequest: [function(data) {}] 请求后的数据处理：transformResponse: [function(data) {}] 自定义的请求头：headers: {‘x-Requested-With’:’XMLHttpRequest’} URL 查询对象：params: {id: 12} 查询对象序列化函数：paramsSerializer: function(params) {} request body：data: {key: value} 超时设置：timeout: 1000 跨域是否带 Token：withCredentials: false 自定义请求处理：adapter: function(resolve, reject, config) {} 身份验证信息：auth: {uname: ‘’, pwd: ‘123’} 响应的数据格式 (json/blob/document/arraybuffer/text/stream)：responseType: ‘json’ axios 实例和模块封装实例创建1234567891011121314151617181920212223const instance1 = axios.create({ baseURL: 'http://ip1' timeout: 1000})instance1({ url: '...', //...}).then(res =&gt; { //...})const instance2 = axios.create({ baseURL: 'http://ip2' timeout: 1000})instance2({ url: '...', //...}).then(res =&gt; { //...}) 模块封装基本封装12345678910111213141516171819//network/request.jsimport axios from 'axios';export function request(config, success, failure) { //创建axios实例 const instance = axios.create({ baseURL: 'http://...', timeout: 1000 }); //发送真正的网络请求 instance(config) .then(res =&gt; { success(res); }) .catch(err =&gt; { failure(err); });} 导入调用 123456789import { request } from './network/request.js';request( { url: '...' }, res =&gt; {}, err =&gt; {}); 方案 212345678910111213141516171819//network/request.jsimport axios from 'axios';export function request(config) { return new Promise((resolve, reject) =&gt; { const instance = axios.create({ baseURL: 'http://...', timeout: 1000 }); }); instance(config) .then(res =&gt; { resolve(res); }) .catch(err =&gt; { reject(err); });} 导入调用 12345import {request} from './network/request.js';request({ url: '...'}).then(res =&gt; {...}).catch(err =&gt; {...}) 最终方案1234567891011//network/request.jsimport axios from 'axios';export function request(config) { const instance = axios.create({ baseURL: 'http://...', timeout: 1000 }); return instance(config);} 导入调用 12345import {request} from './network/request.js';request({ url: '...'}).then(res =&gt; {...}).catch(err =&gt; {...}) axios 拦截器axios 提供了拦截器，用于在发送每次请求或得到响应后，进行对应的拦截 1234567891011121314151617181920212223//全局拦截axios.interceptors()//实例拦截//请求拦截instance.interceptors.request.use(config =&gt; { //请求拦截的作用 //比如config中的一些信息不符合服务器的要求 //比如每次发送网络请求时，都希望在界面中显示一个请求图标 //某些网络请求(比如登陆token)必须携带某些信息 return config;}, err =&gt; {...})//响应拦截instance.interceptor.response.use(res =&gt; { //拦截后操作... //res.data为需要的数据 return res.data;}, err =&gt; { console.log(err);})","link":"/2021/07/29/Vue/"}],"tags":[{"name":"Web","slug":"Web","link":"/tags/Web/"},{"name":"JavaScript","slug":"JavaScript","link":"/tags/JavaScript/"},{"name":"Ajax","slug":"Ajax","link":"/tags/Ajax/"},{"name":"Css","slug":"Css","link":"/tags/Css/"},{"name":"React","slug":"React","link":"/tags/React/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Algorithm","slug":"Algorithm","link":"/tags/Algorithm/"},{"name":"Design","slug":"Design","link":"/tags/Design/"},{"name":"Vue","slug":"Vue","link":"/tags/Vue/"}],"categories":[{"name":"Notes","slug":"Notes","link":"/categories/Notes/"},{"name":"Design","slug":"Design","link":"/categories/Design/"}]}